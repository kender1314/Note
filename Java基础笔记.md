# Java基础笔记

## 继承

### 什么是继承？

多个类存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。

注释：多个类称为子类，一个类称为父类、超类和基类。

 

### 继承语法

```
class 子类名 extends 父类名{

  ……

}
```

###  继承的特点

1. Java只支持单继承，不支持多继承（一个类只能有一个父类，不可能有多个父类）

2. Java支持多层继承（继承体系），即继承有传递性，子类还可以有子类                              

3. 一切类的祖先——java.lang.Object，所有类都直接或者间接地继承了java.lang.Object，Object类提供了以下方法

    ![image-20200726203501158](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203502.png)

4. 子类继承是继承父类的所有东西，除了构造函数

5. 方法重写(覆盖)。子类方法不能缩小父类方法的访问权限，如果没写访问权限（public, private等），则为默认修饰符没有public大

### 继承条件下类的访问权限

子类自动拥有父类申明的public和protected的成员，这是继承特性的体现之一。

private：属性和方法能被子类继承，无法被子类直接使用；<span style="color: red">但是将private属性包装到public方法中</span>，则能被子类使用

public：可以被子类直接使用

protected：同一包中的子类可以使用，另一包中的子类也可以使用

default：如果不知名任何权限，则默认同一包中的类可以访问

 ![image-20200726203512831](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203514.png)

访问权限：public>protected> default>private

注释：private方法只可以在类的内部使用，在类外根本访问不到，而final方法可以在类外访问，但是不可以重写该方法

 

### **java****对象初始化顺序**

1. 父类静态代码块，父类静态成员变量（同级，按代码顺序执行）

2. 子类静态代码块，子类静态成员变量（同级，按代码顺序执行）

3. 父类普通代码块，父类普通成员变量（同级，按代码顺序执行）

4. 父类构造方法

5. 子类普通代码块，子类普通成员变量（同级，按代码顺序执行）

6. 子类构造方法




### 不允许继承的类

```
final class 类名{

 }
```

1.  以final声明的方法不允许覆盖

2.  以final声明的变量不允许更改

3.  利用final可以设计出一种特殊的“只读”的“不可变类”


 用处：可以方便和安全地用于多线程环境中；

   访问它们可以不用加锁，因为能提供较高的性能；

 

### this和super

#### this：当前对象的引用

1. 本类在非静态方法中使用非静态变量和非静态方法，可以使用【this.变量名】和【this.方法名(参数列表)】的方式调用，实际情况是，this关键字通常被省略

2. 在上面的情况下，包含一个特殊情况，假如方法中定义了一个与类成员变量同名的局部变量，这时在方法内部调用类的成员变量就必须使用this关键字来引用

3. 由this函数指向的构造函数默认有super()方法

 

#### super：父类对象的引用

1. 子类重写父类方法之后，再次调用父类的该方法，必须使用【super.方法名(参数列表)】调用

2. 子类的构造方法中默认调用了父类的无参构造方法，也可显示声明其他的构造方法，声明必须使用【super(列表参数)】

3. 在构造方法中，super与this关键字不能同时出现，且位于构造方法首行

4. 静态方法中不能使用super

## 抽象和接口

### 抽象

在Java继承中，抽象类和普通继承关系中的父类作用基本相同，但是却在一般父类的基础上添加了一些限制：

1. 抽象类不能被实例化，即不能被new对象，其子类只有实现了抽象类中的抽象方法子类才能被实例化；如果抽象类中没有抽象方法，则子类可以直接实例化

2. 抽象类除了包含一般方法，变量，常量，同时自身还包含抽象方法

3. 抽象类的子类必须实现抽象类中的所有抽象方法，除非它自己也声明为抽象类，但是这样做，子类则不能被实例化

4. 如果一个类中有抽象方法，则这个类必定是抽象类

5. 抽象方法和抽象类看上去是多余的，当然实际运用中，抽象类能实现的，我们可以使用一般的继承和接口实现，当然，存在即是有道理的，如果熟练运用的话，可以写更少的代码实现相同的功能

6. 抽象方法不可以有函数体（含有大括号的叫函数体）

7. 抽象类可以有构造方法

抽象类举例：

 ![image-20200726203150462](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203413.png)

![image-20200726203403523](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203407.png)

### 接口

从本质上来说，接口是一种特殊的抽象类：

1. 接口由常量和抽象方法组成，接口中的方法可以省略abstract书写

2. public abstract书写（默认方法）, 默认修饰变量属性用：public static final

3. 接口中可以定义default方法，如default void d()；

4. 接口不能被实例化

5. 接口可以继承多个接口

6. 定义default方法时，可以有函数体，函数体内可以有变量。

 

接口举例：

  ![image-20200726203048417](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203052.png)

 ![image-20200726203032542](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203100.png)

 

 

### 抽象类和接口比较

相同点：

都不能直接实例化，即不能直接new对象，通过多态性，可由其子类实例化

不同点：

1. 抽象类包含一般方法，变量，常量，抽象方法；而接口只能包含常量和抽象方法

2. 抽象类可以有构造方法，而接口不能有构造方法

3. 一个类可以实现多个接口，但只能继承一个抽象类

4. 继承抽象类时会引发单继承所带来的局限性，而通过实现接口的方式能够解决单继承带来的局限性

5. 接口里不能定义静态方法，抽象类可以

6. 接口所有方法全是抽象方法只能用public abstract修饰 （默认public abstract修饰 ），属性默认public static final修饰。抽象类除了包含抽象方法外与普通类无区别。

7. 一个类同时要实现接口和继承类，顺序为先继承再实现

 

## Static关键字

### Static简述：

我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。此时就是 static 大显身手的时候了！！

 

### Static变量

特性：

1. 自从static变量被定义起，就会一直在类中存在，如果该变量在使用过程中，值被修改，再次调用该变量时，使用的是被改变后的值，这种情况直到类被卸载（结束）为止。

2. static修饰的变量未赋初始值，如果是int类型，则初始值为0，如果是String类型，则初始值为空。

3. 可以通过类名直接访问静态变量，非静态变量不能直接通过类名访问。

4. Static不能修饰局部变量。

5. 如果没有定义static的方法和变量或者常量，就不会出现线程安全问题。（如果出现多个线程为同一个类的静态变量执行四则运算操作，就涉及到谁先谁后的问题，以及锁的问题）。

 ![image-20200726202918176](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203109.png)

 ![image-20200726202925850](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203115.png)

 

Static定义代码块：

![image-20200726202929889](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203119.png) 

 

### Static方法

特性：

1. 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。

2. 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。

   ![image-20200726202842680](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203125.png)

3. 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量.

4. 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。

   ![image-20200726202832858](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726203131.png)

5. 可以通过类名直接访问静态方法，非静态方法不能直接通过类名访问

6. 定义顺序static final int

 ![](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202534.png)

### static包静态导入

 

如第一行，当引用Math包的时候，如果在引用的时候加static，调用Math中的静态变量和静态方法的时候，就可以直接写变量名或者方法名，而不用这样写：

 ![image-20200726202525988](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202527.png)

 

 

 

## final关键字

### final

1.final修饰的类不能被继承，即不能有子类，final不能修饰抽象类。

2.final修饰的成员变量不能再被改变，即final修饰的是常量。

3.final修饰的方法不能被重写，但是可以被重载

4.final修饰的方法参数不允许在方法体内重新赋值

5.final不能修饰接口

 ![image-20200726202448284](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202539.png)

 ![image-20200726202456744](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202543.png)

 ![image-20200726202500631](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202551.png)

### finalize方法

一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！

## 内部类

在Java中，可以将一个类定义在另一个类里面或者方法里面，这样的类称为内部类。

内部类一般来说包括四种：成员内部类，局部内部类，匿名内部类和静态内部类。

### 成员内部类

成员内部类是最普通的内部类，它的定义位于另一个类内部

 ![image-20200726202317312](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202558.png)

1. 这样看起来，Draw像是Circle类的一个成员，Circle称为外部类，内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和static成员）。

2. 当成员内部类拥有和外部类同名的成员变量或者方法时，就会发生隐藏现象，默认情况下是访问的是成员内部的成员，若要访问外部类的同名成员，则形式为----------------------外部类.this.成员变量、外部类.this.成员方法。

3. 如果外部类要访问内部类的成员，必须先创建内部类的实例化。

 

### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问权限仅限于方法内部或者该作用域内。

 ![image-20200726202352953](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202603.png)

注意：局部内部类就像方法内的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

 

### 匿名内部类

匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。

特性：

1. 匿名内部类只能继承或者实现一个类或者接口

2. 匿名内部类只能用默认的构造方法不能自己添加(匿名内部类根本就没有类名!!!)

3. 匿名内部类就是在创造的时候直接继承某个类，或者实现某个接口

例子1：

 ![image-20200726202406908](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202613.png)

例子2：

 ![image-20200726202422864](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202620.png)

例子2虽然能达到同样的效果，但是冗长又难以维护，所以一般使用第一种方法

匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

 

### 静态内部类（静态嵌套类）

注：静态内部类说法不严谨，正确应该说成静态嵌套类

静态内部类（又名嵌套类）也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。

 ![image-20200726202631786](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202633.png)

 

### 为什么在Java中需要内部类？

1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，

2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。

3.方便编写事件驱动程序

4.方便编写线程代码

 

##  Java集合框架

概述：

1. List , Set, Map都是接口，前两个继承至collection接口，Map为独立接口

2. Set下有HashSet，LinkedHashSet，TreeSet

3. List下有ArrayList，Vector，LinkedList

4. Map下有Hashtable，LinkedHashMap，HashMap，TreeMap

5. collection接口下还有个Queue接口，有PriorityQueue、LinkedList

 ![image-20200726202654408](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202655.png)

 ![image-20200726202703384](../../../Typora/Picture/image-20200726202703384.png)

 

Map   Properties      安全

​    ConcurrentHashMap 安全（采用Segment 的结构保证线程安全）

### Collection：

实现或者继承了collection接口的有List、Set、queue

 

1、Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式

2、Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

异同：Collections 是一个包装类，Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许，一些 collection 是有序的，而另一些则是无序的。

 

### List接口：

— List 有序,可重复

#### Vector

优点: 底层数据结构是数组，查询快，增删慢。

缺点: 线程安全，效率低



#### 可变数组ArrayList

ArrayList底层使用数组作为实现结构，但是元素个数不受限制，是大小可变的数组在内存中分配连续的空间。

 

优点: 底层数据结构是数组，查询快，增删慢。

缺点: 线程不安全，效率高

注：ArrayList集合中的元素是有序的

泛型<E>：可以保证接口中的操作内容更加安全，不这样做就很难避免存储类型杂乱

 

#### 链接表LinkedList

LinkedList底层采用链式存储结构，插入、删除元素是不会引起大量元素的移动，效率高。

它专门提供了对尾部和头部添加和删除的删除方法，而且效率很高

优点: 底层数据结构是链表，查询慢，增删快。

缺点: 线程不安全，效率高

 

### Set接口：

—Set 无序,唯一

HashSet

底层数据结构是哈希表。(无序,唯一)

#### hashCode()和equals()

如何来保证元素唯一性?

1.依赖两个方法：hashCode()和equals()

1）hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

2）hashCode() 在散列表中才有用，在其它情况下没用。

3）“没有覆盖equals()方法”的情况：调用的Object.java的equals()方法，即调用的 (p1==p2)，判断两个对象地址是否相等，比较“p1和p2是否是同一个对象”。

4）“覆盖equals()方法”的情况：判断两个对象是否相等。

5）String类满足拥有相同字符的字符串产生同样的哈希码，即只要满足equals相等，hashCode就相等。

 

 

LinkedHashSet

底层数据结构是链表和哈希表。(FIFO插入有序,唯一)

1. 由链表保证元素有序

2. 由哈希表保证元素唯一

 

TreeSet

底层数据结构是红黑树。(唯一，有序)

1. 如何保证元素排序的呢?

自然排序

比较器排序

2. 如何保证元素唯一性的呢?

根据比较的返回值是否是0来决定

Set接口特点：

 \* （1）无序的，即放进去的顺序和出来的顺序不同

 \* （2）不可重复，注重独一无二的性质

 \* （3）HashSet继承自AbstractSet

 \* Set接口有两个重要的实现类：HashSet和TreeSet

l HashSet

引用相等性：引用堆上同一对象的两个引用是相等的。

对象相等性：堆上的两个不同对象在意义上是相同的。

引用相等性被HashSet认为是重复元素，但是对于对象相等性，HashSet并不认为是重复的。

l TreeSet

TreeSet存储自定义类型的对象

### Iterator迭代器：

（1）使用iterator()要求容器返回一个Iterator。

（2）注意：iterator()方法是java.lang.Iterable接口,被Collection继承。

（3）使用next()方法获得序列中的下一个元素 

（4）使用hasNext()检查序列中是否还有元素

（5）使用remove()方法将迭代器新返回的元素删除

（6）Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，

 *它可以从两个方向遍历List，也可以从List中插入和删除元素。

 

### Map接口：

Map接口有三个比较重要的实现类，分别是HashMap、TreeMap、Properties和HashTable。

1. TreeMap是有序的，HashMap和HashTable是无序的。

2. Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。

3. 这就意味着:Hashtable是线程安全的，HashMap不是线程安全的。

4. HashMap效率较高，Hashtable效率较低。

5. 如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。

6. Hashtable不允许null值，HashMap允许null值（key和value都允许）

7. 父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap

（1）键（Key）不允许重复。 

（2）一个键（Key）只能映射到一个值（Value）。

（3）Map接口本身有3个常用子类：HashMap，HashTable，TreeMap，但是HashTable已经标为过时。

 

#### HashMap

![image-20200911230433081](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911230443.png)

（1）   集合中的元素不会按次序排列

（2）   HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。

（3）   HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。

（4）   HashMap实现不同步，线程不安全。 HashTable线程安全

（5）   HashMap中的key-value都是存储在Entry中的。

（6）   HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性

（7）   解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的

**HashMap****常用方法：**

 

```
*void clear()-------------------------------------清除所有映射单元
*Set<K> keySet()----------------------------------返回所有key的集合
*Collection<V> values()---------------------------返回所有值得集合
*Set<Map.Entry<K, V>> entrySet()------------------返回键值对的集合
*V get(Object key)--------------------------------根据键取得值
*V put(K key, V value)----------------------------存值
*V remove(Object key)-----------------------------删除指定键所对应的值
*void putAll(Map<? extends K, ? extends V>m)------集合复制
*boolean containsKey(Object key)------------------判断是否包含某个键
*boolean containsValue(Object value)--------------判断是否包含某个值
```

 

l TreeMap

（1）TreeMap底层采用红黑树结构，而HashMap使用哈希表结构

（2）TreeMap中的元素按Key自动排序，而HashMap是无序的

（3）TreeMap常用方法：

```
 *void clear()-------------------------------------清除所有映射单元
 *Set<K> keySet()----------------------------------返回所有key的集合
 *Collection<V> values()---------------------------返回所有值得集合
 *Set<Map.Entry<K, V>> entrySet()------------------返回键值对的集合
 *V get(Object key)--------------------------------根据键取得值
 *V put(K key, V value)----------------------------存值
 *V remove(Object key)-----------------------------删除指定键所对应的值
 *void putAll(Map<? extends K, ? extends V>m)------集合复制
 *boolean containsKey(Object key)------------------判断是否包含某个键
 *boolean containsValue(Object value)--------------判断是否包含某个值
```

 

 

### 队列queue：

**概述：**

1. 队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

2. LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。

 

**两个基本用法:**

1. 在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞

2. 在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。

 

 

**基本操作：**

add     增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常

remove    移除并返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常

element   返回队列头部的元素   如果队列为空，则抛出一个NoSuchElementException异常

offer      添加一个元素并返回true   如果队列已满，则返回false

poll      移除并返问队列头部的元素  如果队列为空，则返回null

peek     返回队列头部的元素     如果队列为空，则返回null

put     添加一个元素        如果队列满，则阻塞

take      移除并返回队列头部的元素  如果队列为空，则阻塞

 ![image-20200726202024339](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726202029.png)

 

### Java常用的数据结构

数组、栈 、队列、链表、树、堆 、图、散列表（哈希表）。

1. 数组是计算机编程语言上，对于“Array”的中文称呼，是用于储存多个相同类型数据的集合。

2. 栈是限定仅在表尾进行插入和删除操作的线性表，栈者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。

3. 一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

4. 链表，一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

5. 哈希表，是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

 

## JVM虚拟机

- Java 虚拟机：Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。

- JVM实现了Java语言最重要的特征：即平台无关性。

- 原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证，同时也是 Java 程序的安全检验引擎（还进行安全检查）。

- JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area。类加载器（classloader）把硬盘上的class 文件加载到JVM中的运行时数据区域（runtime data area）, 但是它不负责这个类文件能否执行，而这个是执行引擎（execution engine）负责




### classloader

l 作用：装载.class文件

l classloader 有两种装载class的方式 （时机）：

隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM

显式：通过class.forname()动态加载

**双亲委派模型**

1. 当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。

2. 当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.

3. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。

![image-20200726201907455](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201908.png)

 

### Jvm内存区

JVM内存区：程序计数器、虚拟机栈、本地方法栈、堆、方法区（包括常量池）。

1.程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。

2.Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。

3.本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。

4.Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。

5.方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。

6.运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。

  ![image-20200726201828317](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201829.png)

 

 

**JVM****中**

堆区：只存放类对象，线程共享，以及存放用new产生的数据；

方法区：又叫静态存储区，存放class文件和静态数据，线程共享;

栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;

全局区：全局变量，以及static变量

 

**进程的区**

一条进程的栈区、堆区、数据区和代码区在内存中的映射 
   1>栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。 
   2>堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你能够 free和delete它们。 
   3>数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。 

 

## 重写，覆盖，重载

### 构造方法

1. 在同一个类中，如果一个方法要调用构造方法，这个构造方法应该被定义成private权限的方法，同时不能被子类继承。

2. 构造方法不能被对象调用，只会创建对象，使用new关键字




### 重写（覆盖）

**定义**：一般是用于子类在继承父类时，重写（重新实现）父类中的方法

**规则**：方法重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。

1、重写方法的参数列表必须完全与被重写的方法的相同

2、子类中方法的访问修饰符必须 >= 父类中对应方法的访问修饰符（public>protected>default>private）。

3、重写的方法的返回值必须和被重写的方法的返回一致；

4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；

5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。

6、静态方法不能被重写为非静态的方法（会编译出错）。

7、构造函数不能被继承，构造方法只能被显式或隐式的调用。

### 重载

**定义**：在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。

**规则**：

1、在使用重载时只能通过相同的方法名、不同的参数形式实现。可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）；

  2、不能通过访问权限、返回类型、抛出的异常进行重载；

  3、方法的异常类型和数目不会对重载造成影响；

 

## &、|、^、~、>>、>>>

l &和|属于位运算符 不管前面的条件是否正确，后面都执行

l ＆ 如果相对应位都是1，则结果为1，否则为0

l | 如果相对应位都是0，则结果为0，否则为1

l ^是异或运算符两个操作数的位中，相同则结果为0，不同则结果为1。

l ~是位运算符，意义是 按位非（NOT）

按位非也叫做补，一元运算符NOT“~”是对其运算数的每一位取反。

仅用于整数值

反转位，即0位变为1位，1变成0

在所有情况下〜x等于（-x）- 1

l <<表示左移移，不分正负数，低位补0；　

例子：正数：r = 20 << 2

　　   20的二进制补码：0001 0100

　　   向左移动两位后：0101 0000

　　   结果：r = 80

负数：r = -20 << 2

　　   -20 的二进制原码 ：1001 0100

　　   -20 的二进制反码 ：1110 1011

　　   -20 的二进制补码 ：1110 1100

　　   左移两位后的补码：1011 0000

　　　　　　　　反码：1010 1111

　　　　　　　　原码：1101 0000 

　　　　　　　　结果：r = -80

l >>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；

例子：正数：r = 20 >> 2

　    20的二进制补码：0001 0100

　　   向右移动两位后：0000 0101

　　　　　　　结果：r = 5

负数：r = -20 >> 2

　　   -20 的二进制原码 ：1001 0100

　　   -20 的二进制反码 ：1110 1011

　　   -20 的二进制补码 ：1110 1100 

　　   右移两位后的补码：1111 1011 

　　　　　　　　反码：1111 1010

　　　　　　　　原码：1000 0101

　　　　　　　　结果：r = -5

l >>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0

 

例子：正数：　r = 20 >>> 2

　　　   结果与 r = 20 >> 2 相同；

负数：　r = -20 >>> 2

　　  -20:源码：10000000 00000000 00000000 00010100

　　　　反码：11111111 11111111  11111111  11101011

　　　　补码：11111111 11111111  11111111  11101100

　　　　右移：00111111 11111111  11111111  11111011

　　　　结果：r = 1073741819

 

 

## 数据类型分类

基本数据类型（或叫做原生类、内置类型）8种：

​       整数：byte，short，int，long（默认是int类型）

​       浮点类型： float，double（默认是double类型）

​       字符类型：char

​       布尔类型：boolean

引用数据类型5种：类 接口 数组 枚举 标注

（String属于引用数据类型，因为String是一个类）

注释：如果将基本数据类型定义的值传入方法中，只是将该值的地址传进去，当该方法返回该值时，原方法中该常量的值并没有改变，引用数据类型则恰恰相反，原方法中的常量的值会改变。

 ![image-20200726201656339](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201658.png)

### 各类型占用字节数：

 

|         | 默认值    | 存储需求（字节） | 取值范围     | 示例               |
| ------- | --------- | ---------------- | ------------ | ------------------ |
| byte    | 0         | 1                | -2^7—2^7-1   | byte b=10;         |
| char    | ‘ \u0000′ | 2                | 0—2^16-1     | char c=’c’ ;       |
| short   | 0         | 2                | -2^15—2^15-1 | short s=10;        |
| int     | 0         | 4                | -2^31—2^31-1 | int i=10;          |
| long    | 0         | 8                | -2^63—2^63-1 | long o=10L;        |
| float   | 0.0f      | 4                | -2^31—2^31-1 | float f=10.0F      |
| double  | 0.0d      | 8                | -2^63—2^63-1 | double d=10.0;     |
| boolean | false     | 1                | true\false   | boolean flag=true; |

 

### 引用数据类型和基本数据类型

引用数据类型是引用传递（call by reference）：引用传递不可以改变原变量的地址，但可以改变原变量的内容

 ![image-20200726201558105](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201705.png)

 

 基本数据类型是值传递（call by value）：值传递不可以改变原变量的内容和地址

 ![image-20200726201549261](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201711.png)

 

 

### 引用类型

1. 强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。

2. 软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。

3. 弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。

4. 虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。

 

## 12.节点流和处理流

按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。

节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.

处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。

### JAVA常用的节点流：

l 文 件 

FileInputStream，FileOutputStrean，FileReader FileWriter 文件进行处理的节点流。

l 字符串 

StringReader，StringWriter 对字符串进行处理的节点流。

l 数 组 

ByteArrayInputStream，ByteArrayOutputStream，CharArrayReader，CharArrayWriter，对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。

l 管道 

PipedInputStream，PipedOutputStream， PipedReaderPipedWriter，对管道进行处理的节点流。

### 常用处理流（关闭处理流使用关闭里面的节点流）

 

l 缓冲流

BufferedInputStrean，BufferedOutputStream，BufferedReader BufferedWriter ，增加缓冲功能，避免频繁读写硬盘。

l 转换流

InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。

l 数据流 

DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

### 流的关闭顺序

一般情况下是：先打开的后关闭，后打开的先关闭

另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b

可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。

 

## 异常exception

Java中的异常分为两大类：

1. java异常类均继承于java.lang.Throwable。

2. **checked exception**：指的是编译时异常，该类异常需要本函数必须处理的，用try和catch处理，或者用throws抛出异常，然后交给调用者去处理异常。

3. **runtime exception**：指的是运行时异常，该类异常不必须本函数必须处理，当然也可以处理。

![image-20200726201449421](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201451.png)

 

 

## 正则表达式

参考文档：https://www.runoob.com/java/java-regular-expressions.html

 

### 包含的类：

Pattern 类：

pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

 

Matcher 类：

Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

 

PatternSyntaxException：

PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

 

### 正则表达式语法

 

## 运算优先级

![image-20200726191608194](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726191609.png)

 

## 文件名后缀

- .class 编译后的Java文件 
- .java是未编译的程序 
- .jsp是页面程序 
- .xml配置程序 
- .jar是.calss的集合
- .exe为可执行文件




转化过程：java中源文件的后缀为.java，经过javac.exe编译后生成字节码文件，后缀为.class，再经过java.exe编译为可执行文件，后缀为.exe。

 

Java.exe是java虚拟机

javadoc.exe用来制作java文档

jdb.exe是java的调试器

javaprof.exe是剖析工具

 

## ASCII码值

常见字符的ASCII码值如下：空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。

 

## 面向对象的六大基本原则和三大特性

### 封装

l 将对象的属性和实现细节隐藏起来，只提供公共的访问方式。

### 继承

l 继承是从已有的类派生出新的类，新的类能继承已有类的数据属性和行为，并扩展新的功能。

### 多态

l 允许不同类型的子对象对统一消息做出不同的响应。

 

### 单一职责原则（SRP）：

l 一个类应该仅有一个引起它变化的原因

### 开放封闭原则（OCP）： 

l 既开放又封闭，对扩展是开放的，对更改是封闭的！

l 扩展即扩展现行的模块，当我们软件的实际应用发生改变时，出现新的需求，就需要我们对模块进行扩展，使其能够满足新的需求！

l 更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件

### 里氏替换原则（LSP）： 

l 子类可以替换父类并且出现在父类能够出现的任何地方

l 这个原则也是在贯彻GOF倡导的面向接口编程！

l 在这个原则中父类应尽可能使用接口或者抽象类来实现！

### 依赖倒置原则（DIP）： 

传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！

所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！

 

### 接口隔离原则（ISP）：

l 使用多个专门的接口比使用单个接口要好的多！

 

## 处理字节流和字符流

字节流：

InputStream  

|-- FileInputStream (基本文件流）  

|-- BufferedInputStream  

|-- DataInputStream  

|-- ObjectInputStream

字符流

Reader

|-- InputStreamReader (byte->char 桥梁） 

|-- BufferedReader (常用） 

Writer

|-- OutputStreamWriter (char->byte 桥梁） 

|-- BufferedWriter 

|-- PrintWriter （常用）

 

 

## String,StringBuffer与StringBuilder

**String** **字符串常量****
 \**StringBuffer\**** **字符串变量（线程安全）****
 \**StringBuilder\**** **字符串变量（非线程安全）**

 

String 类型和 StringBuffer 类型区别：主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。

StringBuffer 类则结果就不一样，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用

 

Java.lang.StringBuffer是线程安全的可变字符序列，一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。

 

java.lang.StringBuilder：一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

 

 

## Java标识符命名规则

l 由26个英文字母大小写，数字：0-9 符号：_ $ 组成

l 标识符应以字母、_ 、$开头。

l 标识符不能是关键字。

l Java中严格区分大小写

 

## Java单例模式

### 单例模式主要有3个特点：

1、单例类确保自己只有一个实例。

2、单例类必须自己创建自己的实例。

3、单例类必须为其他对象提供唯一的实例

### 单例模式的优点：

Java Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）

 

常见单例模式的实现方式：懒汉单例类和饿汉单例类

### 懒汉单例

定义：对于懒汉模式，我们可以这样理解：该单例类非常懒，只有在自身需要的时候才会行动，从来不知道及早做好准备。它在需要对象的时候，才判断是否已有对象，如果没有就立即创建一个对象，然后返回，如果已有对象就不再创建，立即返回。

注：懒汉模式只在外部对象第一次请求实例的时候才去创建。

 

代码示例：

```
public class Singleton2{
  private static Singleton2 a ;
  public static Singleton2 getSingleton2(){
      if(a==null){
        a = new Singleton2();
      }
      retrun a;
    }
}
```

 

 

### 饿汉单例

定义：饿汉模式，该单例类非常饿，迫切需要吃东西，所以它在类加载的时候就立即创建对象

 

代码示例：

```
public class Singleton1{

  private static Singleton1 a = new Singleton1();

  public static Singleton1 getSingleton1(){
      retrun a;
    }
}
```

 

### 懒汉单例类和饿汉单例类的区别：

1. 饿汉模式是线程安全的而懒汉模式存在安全问题,如需解决需添加双重检查锁机制

2. **懒汉模式**：它的特点是运行时获得对象的速度比较慢，但加载类的时候比较快。它在整个应用的生命周期只有一部分时间在占用资源。

   **饿汉模式**：它的特点是加载类的时候比较慢，但运行时获得对象的速度比较快。它从加载到应用结束会一直占用资源。

3. 对重量级对象应用饿汉模式，类加载时速度慢，但运行时速度快；懒汉模式则与之相反，类加载时速度快，但运行时第一次获得对象的速度慢。

 

### 什么情况下使用单例模式：

1. 控制资源的使用，通过线程同步来控制资源的并发访问；

2. 控制实例产生的数量，达到节约资源的目的。

3. 作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。

 

## J2EE容器

WEB容器：给处于其中的应用程序组件（jsp，servlet）提供一个环境，使jsp，servlet直接与容器中的环境变量交互，不必关注其它系统问题。主要由WEB服务器来实现。 例如：tomcat,weblogic,websphere等。

EJB容器：Enterprise java bean容器。供给运行在其中的组件EJB各种管理功能,满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理,并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。

WEB容器更多的是跟基于HTTP的请求打交道。而EJB容器更多的和数据库、其它服务打交道。但他们都是把与外界的交互实现从而减轻应用程序的负担。例如SERVLET不用关心HTTP的细节，直接引用环境变量session,request,response就行、EJB不用关心数据库连接速度、各种事务控制，直接由容器来完成。

 

## throw与throws

异常有两个过程，一个是抛出异常；一个是捕捉异常。

### 抛出异常

抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常

### 系统自动抛异常

当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。

 

### throw

throw是语句抛出一个异常。

语法：throw (异常对象);

   如： throw e;

 

一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常。

 

### throws

throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)

语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]{......}

   如：   public void function() throws Exception{......}

 

当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理。

 

### throw与throws的比较

1、throws出现在方法函数头；而throw出现在函数体。

 

2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。

 

3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

 

 

## 内联函数

1.内联函数就是指函数在被调用的地方直接展开，编译器在调用时不用像一般函数那样，参数压栈，返回时参数出栈以及资源释放等，这样提高了程序执行速度。

 

2.Java语言中有一个关键字final来指明那个函数是内联的，例：

 

public final void doSomething() {

 // to do something

}

\3. 内联不一定好，当被指定为内联的方法体很大时，展开的开销可能就已经超过了普通函数调用调用的时间，引入了内联反而降低了性能，因为在选择这个关键字应该慎重些，不过，在以后高版本的JVM中，在处理内联时做出了优化，它会根据方法的规模来确定是否展开调用。

## java关键字

![image-20200726191431261](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726191631.png)

 

##  Java中的序列化和反序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。

### 序列化作用

1.方便传输，速度快，还很安全，被调用方序列化，调用方反序列化即可拿到传输前最原始的java对象，常用于不同进程之间的对象传输

2.方便存储，不管是存储成文件还是数据库，都行，存储为文件，下回要用可以直接反序列拿到对象

### 如何使Java类可序列化？

通过实现java.io.Serializable接口，可以在Java类中启用可序列化。它是一个标记接口，意味着它不包含任何方法或字段，仅用于标识可序列化的语义。

 

### 如果我们试图序列化不可序列化的对象怎么办？

我们将得到一个 RuntimeException 异常：主线程中出现异常 java.io.NotSerializableException。

 

### Transient 关键字

transient修饰符仅适用于变量，不适用于方法和类。在序列化时，如果我们不想序列化特定变量以满足安全约束，那么我们应该将该变量声明为transient。执行序列化时，JVM会忽略transient变量的原始值并将默认值保存到文件中。因此，transient意味着不要序列化。

### 注意事项

1. 为了不必要的报错麻烦： 序列化时最好是定义序列化版本id 即 public static final Long seriaVersionUID = 1L (默认) 或者 xxxxx L（自定义64位都行）。

2. 因为反序列化会判断序列化中的id和类中的id是否一样，如果不定义虽然会自动生成，但如果后面改了东西列，所以还是自觉点定义一个id，省去好多麻烦。

3. 同时记住静态变量不会被序列化的，它可不在堆内存中，序列化只会序列化堆内存。

 

## int和Integer

①无论如何，Integer与new Integer不会相等。不会经历拆箱过程

②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false，java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数只会对-128到127之间的数进行缓存 

③两个都是new出来的,都为false 

④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比

 

 

## IO流

### 字节流和字符流

字节流：可以处理所有类型的数据，如MP3，文字，视频等。在读取时，都到一个字节就返回一个字节。

在java中对应的类都以“Stream”结尾。

字符流：仅能处理文本数据，如TXT文本等。读到一个或者多个字节时，先查找制定的编码表，然后将查到的字符返回。

在java中对应的类都以“Writer”或“Reader”结尾。

### 字符字节与编码

字符：人们试用的记号；

举例：“1”,”“中”，“@”等；

字节：计算机中存储数据的单元，一个八位的二进制数，是一个很具体的储存空间；

举例：0x01，0x45.0xFA等（这里用16进制表示的）；

ANSI编码：系统预设的标准文字储存格式，不同国家和地区试用不同的标准；

Unicode：国际组织统一规定的UNICODE字符集，满足跨语言，跨平台进行文本转、处理的要求。

### Buffer代表缓冲区的意思

带有缓冲的的字节输出流效率是非常高的，尤其是在进行大型文件的复制的时候，使用Buffer进行复制要快得多。

InputStreamReader：将字节流转换为字符流

 

## 同步与异步

**定义：**

1. 同步:发送一个请求,等待返回,然后再发送下一个请求 

2. 异步:发送一个请求,不等待返回,随时可以再发送下一个请求 

**概念：**

同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。

异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。

 

**区别：**

同步和异步最大的区别就在于。一个需要等待，一个不需要等待。

比如广播，就是一个异步例子。发起者不关心接收者的状态。不需要等待接收者的返回信息
 **举例：**

电话，就是一个同步例子。发起者需要等待接收者，接通电话后，通信才开始。需要等待接收者的返回信息

 

## lambda表达式

### Lambda简介

Lambda表达式，也可称为闭包，它是推动Java8发布的最重要的新特性。

Lambda允许把函数为一个方法的参数（函数作为参数传递进方法中）。

### Lambda的优势

1. 使用lambda表达式可以使代码变得更加简介紧凑。
2. 尤其是集合的遍历和其他集合操作中，可以极大地优化代码结构。

### Lambda对接口的要求

Lambda规定接口中<span style="color: red">只能有一个必须需要被实现的方法</span>，不是规定接口中只能有一个方法。

如下面这个例子：

![image-20200726194105385](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726194108.png)

如果使用default，并且为方法定义方法体，就可以有多个方法。method方法则是为必须需要被实现的方法。

@**FunctionalInterface**

专门用于修饰函数式接口，要求接口中的抽象方法只有一个。这个注解一般会和lambda表达式一起使用。



### 表达式示例：

示例1：

 ![image-20200704173214107](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726191342.png)

示例2：

 ![image-20200726191335240](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726191337.png)

### lambda使用场景

1. 实现延迟执行

   延迟执行的大概原因：

   1) 另一个单独的线程运行代码

   2) 多次运行代码

   3) 在算法的恰当时刻运行代码（例如，排序中的比较操作）

   4) 当某些情况发生时运行代码（按钮被单击、数据到达等）

   5) 只有在需要的时候运行代码

2. 延迟执行的

 

### Lambda的作用域

Lambda表达式的方法体与嵌套代码块有着相同的作用域。因此，也适用同样的命名冲突和屏蔽规则。

  

## 方法引用和构造函数引用

### 方法引用

方法引用示例：

 ![image-20200726201310229](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201312.png)

操作符::将方法名称或类对象名称分隔开，三种书写方式：

1. 类::实例方法

2. 类::静态方法

3. 对象::实例方法

 

### 构造函数引用

 

## java日志logger 

### 日志记录器

定义：日志记录的载体。系统也有全局日志记录器，可以自己定义日志记录器。

创建示例：

 ![image-20200726201248900](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201249.png)

 

### 日志级别

日志共分为7个级别：

 ![image-20200726201223335](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201224.png)

默认情况下，前三个级别的日志会被记录下来。也可以设置不同的阀值，如：![image-20200726201234832](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201237.png)  ，FINE及以上级别的日志就会被记录下来。

 

## 泛型编程

泛型学习网址https://www.cnblogs.com/penghuwan/p/8420791.html

### 泛型的意义：

一般来说，你并不想要编写多个分别处理不同数据类型，但内在逻辑代码却完全一样的类。因为这些处理类可能除了数据类型变换了一下外，所有代码都完全一致。

### 泛型特性

1. JavaSE7以后，在实例化一个泛型类对象时，构造函数中可以省略泛型类型

![image-20200726201022856](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201024.png)

2. *T extends SuperClass* 与 *? extends SuperClass*的使用与区别

编译器可以通过泛型定义变量，但是不能通过通配符定义变量，

通配符需要调用泛型定义的方法进行变量定义：

 ![](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201101.png)

泛型（T）：

![image-20200911230817706](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911230819.png)

通配符（?）:

 ![image-20200726201117452](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201118.png)

3. 对于要求实现接口， 或者继承自某个父类， 统一使用extends关键字

4. 问题

 ![image-20200726201133322](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201135.png)

 ![image-20200726201145756](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201147.png)

### 泛型方法：

泛型变量T放在修饰符（这里是public static）的后面， 返回类型的前面

 ![image-20200726201157607](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200726201158.png)



## Java反射

反射链接：[反射学习网址](https://www.sczyh30.com/posts/Java/java-reflection-1/#一、回顾：什么是反射？) 

### 什么是反射

反射：将类中的各个组成部分封装为其他对象，这就是反射机制。

反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。

 

在java.lang.reflect包中有三个类：Field类、Method类和Constructor类分别描述了一个类的域、方法、构造函数。Field类有一个getType方法，该方法返回一个Class类型的对象，描述域的类型信息。

![image-20200911230856558](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911230858.png)



**反射主要提供的功能：**

-   在运行时判断任意一个对象所属的类；


- 在运行时构造任意一个类的对象；

- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；

- 在运行时调用任意一个对象的方法


重点：**是运行时而不是编译时**

### 反射主要用途

**反射最重要的用途就是开发各种通用框架。**很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。



### 反射结构图

![image-20200709224741725](../../../Typora/Picture/20200709224745.png)

### 反射的好处

1. 可以在程序运行过程中，操作这些对象。

   在Idea运行过程中，就可以使用代码自动补全工具，比如输入string.之后，会提示你想要输入的方法（本例中使用了length()方法）：

   ```
   String string = "";
   System.out.println(string.length());
   ```

   为什么我能调用string的length()方法呢，这就是通过反射原理。

2. 可以解耦，提高程序的可扩展性。

### 获取类对象的方式

总共分为三种方式，分别对应Java代码在计算机中的三个方向：

1. Class.forName("全类名")：将字节码文件 加载进内存，返回Class对象。（全类名：包路径+类名）。（源代码阶段（Source））

   *多用于配置文件

2. 类名.class：通过类名的属性class获取。（类对象阶段阶段（Class））

   *多用于参数传递

3. 实例对象.getClass()：getClass()方法在Object中定义的。（运行时阶段（Runtime））

   *多用于对象的获取字节码的方式

结论：在一次程序运行过程中，同一个字节码文件，只会被加载一次，不管你用什么方式将该类加载进入内存，获取到的Class对象，都是同一个。

### Class对象功能

#### 获取功能

##### 获取成员变量数组

```
Field[] getFields()
Field getField(String name)

Field[] getDeclaredFields()  //可以获取所有类型字段，包括private类型
Field getDeclaredField(String name) 
```

主要作用：

1. 可以通过set(Object obj, Object value)为类字段设置值

   ```
   People people = new People();
   Field interest = cls.getField("interestPublic");
   interest.set(people, "football");
   ```

2. 可以通过get(Object obj)获取类中字段的值

   ```
   Object o = interest.get(people);
   ```

3. 通过getDeclaredFields和getDeclaredField可以试想暴力反射，连对象的private变量也可以设置值以及获取值

   ```
   Field name = cls.getDeclaredField("name");
   System.out.println("\ngetDeclaredField获取指定类字段，可获取所有类型字段->>>\n" + name);
   //需要设置忽略访问权限修饰符的安全检查
   name.setAccessible(true);   //暴力反射
   name.set(people, "hejia");
   Object o = name.get(people);
   System.out.println("\ngetDeclaredField获取private字段的值->>>\n" + o);
   ```

##### 获取构造方法数组

```
Constructor<?>[] getDeclaredConstructors() 
Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) 

Constructor<T> getConstructor(Class<?>... parameterTypes) 
Constructor<?>[] getConstructors() 
```

可以通过类的构造方法，创建类的实例对象

```
Class cls = People.class;
Constructor constructor = cls.getConstructor(String.class, Integer.class);
assert constructor != null;
Object obj = constructor.newInstance("hejina", 22);
System.out.println(obj);
```



##### 获取成员方法数组

```
Method getDeclaredMethod(String name, Class<?>... parameterTypes) 
Method[] getDeclaredMethods() 

Method getMethod(String name, Class<?>... parameterTypes) 
Method[] getMethods() 
```

invoke()方法，其实是调用该类的指定方法。

##### 获取类名

```
String getName()
```



## 反射案例

需求：写一个“框架”，在不修改代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意的方法。

解决思路：

1. 配置文件
2. 反射

解决步骤：

1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
2. 在程序中加载读取配置文件
3. 使用反射技术来加载类文件进内存，
4. 创建对象
5. 执行方法





## Stream

 





## 多线程

### 进程和线程

**进程：**是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态的概念，竞争计算机系统资源的单位。缺点：创建进程的话，进程之间资源不共享

 `对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。`

`有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。`

`由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。`

**线程：**是进程的一个执行单位，CPU调度和分配的基本单位，进程内部调度实体。比进程更小的独立运行单位。线程也被称为轻量级进程。



### **线程与进程的关系**

1. 每个进程都需要操作系统为其分配独立的内存地址空间，而同一进程中的所有线程都在同一块地址空间中工作，这些线程可以共享同一块内存和系统资源，比如共享一个对象或共享已经打开的一个文件。
2. 进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。



### 线程的状态

**创建线程有两种方式：**

-----扩展java.lang.Thread类

1. 不要随便覆盖Thread类的start()方法

2. 一个线程只能被启动一次，一次实例化只能调动一次start()方法

-----实现Runnable接口

1. java不允许一个类继承多个类，因此提供了Runnable接口

 

-----实现Callable接口

1. 是Runable接口的增强版

2. 用Call()方法作为线程的执行体，增强了之前的run()方法。call方法可以有返回值，也可以声明抛出异常。

   

**线程的状态转换：**

1. 新建状态（New）

用new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅仅在堆区中被分配了内存。

2. 就绪状态（Runnable）

当一个进程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态，Java虚拟机会为它创建方法调用栈和程序计数器。等待获取CPU使用权

3. 运行状态（Running）

处于这个状态的线程占用CPU，执行程序代码。只用处于就绪状态的线程才有机会转到运行状态

4. 阻塞状态（Blocked）

阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。直到线程重新进入就绪状态，它才有机会转到运行状态。

阻塞状态可以分为3种：

（1）  位于对象等待池中的等待状态（Blocked in object’s wait pool）：当线程处于运行状态时，如果执行某个对象的wait()方法，Java虚拟机就会把线程放到这个对象的等待池中。

（2）  位于对象锁池中的等待状态（Blocked in object’s lock pool）：当线程处于运行状态，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中。

（3）  其他阻塞（Otherwise Blocked）：当前线程执行了sleep()方法，或者调用了其他线程的join()方法，或者发出I/O请求时（当一个线程执行System.out.println()和System.in.read()，就会发出一个I/O请求），就会进入这个状态。

5. 死亡状态（Dead）

线程可能正常执行完run()方法而退出，也有可能是遇到异常而退出。不管线程是正常退出还是异常退出，都不会对其他线程造成影响。

### 线程调度

所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU使用权，分别执行各自的任务，Java虚拟机的一项任务就是负责线程的调度，采用抢占式调度模型。

**抢占式调度模型**

是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中线程的优先级相同，那么随机选择一个线程，使其占用CPU。

**设置线程优先级**

Tread类setPriority(int)和getPriority()方法分别用来设置优先级和读取优先级

**Thread.sleep()方法**

不会释放对象锁

**Thread.yield()方法**

运行状态线程执行yield()方法时，如果此时具有相同优先级的其他线程处于就绪状态，那么yield()方法将把当前运行的线程放到可运行池中并使另一个线程运行。如果没有相同优先级的可运行线程，则yield()方法什么都不做。

**join()方法**

当前运行的线程可以调用另一个线程的join()方法，当前运行的线程将转到阻塞状态，直到另一个线程运行结束，它才会恢复运行。

**interrupt()方法**

中断线程，用于中断当前正在运行的线程

 

**suspend() 和 resume() 方法：**

两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态



**wait和notify之间的线程通信**

不同的线程执行不同的任务，如果这些任务有某种联系，线程之间必须能够通信，协调完成工作。

java.lang.Object类中提供了两个用于线程通信的方法：

l wait()：执行该方法的线程释放对象锁，java虚拟机把该线程放到该对象的等待池中。该线程等待其他线程将它唤醒。

l notify()：执行该方法的线程唤醒在对象的等待池中等待的线程，Java虚拟机从对象的等待池中随机选择一个线程，把它转到对象的锁池中。

 

**sleep和wait的区别有：**

1. 这两个方法来自不同的类分别是Thread和Object

2. 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。

3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用 

4. wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法

5. sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

6. Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException

7. Thread.sleep()抛出的InterruptException属于checked exception；IllegalArgumentException属于Runtime exception;

**后台线程：**

后台线程区别于普通线程，普通线程又可以称为用户线程，只完成用户自己想要完成的任务，不提供公共服务。而有时，我们希望编写一段程序，能够提供公共的服务，保证所有用户针对该线程的请求都能有响应。

**后台线程转换及判断：**在线程调用start()方法之前，调用Thread类的setDaemon(true)方法，就能把一个线程设置为后台线程，Thread类的isDaemon()方法用来判断一个线程是否是后台线程。

**定时器Timer**

详情见代码TimerTest.java



### 线程同步volatile和synchronized

#### 多线程编程中的三个核心概念

**原子性：**跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。

 

**可见性：**当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。

 

**顺序性：**顺序性指的是，程序执行的顺序按照代码的先后顺序执行。

举例：

​                               

从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。CPU虽然不一定按照代码顺序执行代码，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。

 

#### synchronized和volatile表达方式

**synchronized****表达式：**

表达1（修饰变量）：

synchronized(this){

​    变量

}

表达2（修饰方法）：

public synchronized String pop(){

​    …

}

**volatile****表达式：**

 

public volatile int i = 0;（只能修饰变量级别）

 

#### happens-before原则（先行发生原则）

l 传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性

l 锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取

l volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作

l 程序次序规则：一个线程内，按照代码顺序执行

l 线程启动规则：Thread对象的start()方法先发生于此线程的其它动作

l 线程终结原则：线程的终止检测后发生于线程中其它的所有操作

l 线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取

l 对象终结规则：一个对象构造先于它的finalize发生

 

#### 线程同步特征

\1.  如果一个同步代码块和非同步代码块同时操纵共享资源，仍然会造成对共享资源的竞争。

\2.  每个对象都有唯一的同步锁。

\3.  在静态方法前面也可以使用synchronized修饰符。

\4.  当一个线程开始执行同步代码块时，并不意味着必须以不中断的方式运行。

\5.  Synchronized声明不会被继承

\6.  假如这把锁已经被其他线程占用，Java虚拟机就会把这个消费者线程放到Stack对象的锁池中，消费者线程进入阻塞状态。

 

 

 

#### volatile与synchronized区别

（1）volatile修饰的变量，jvm每次都从主存（主内存）中读取，而不会从寄存器（工作内存）中读取。而synchronized则是锁住当前变量，同一时刻只有一个线程能够访问当前变量

 

（2）  volatile仅能用在变量级别，而synchronized可用在变量和方法中

 

（3）  volatie仅能实现变量的修改可见性，无法保证变量操作的原子性。而

synchronized可以实现变量的修改可见性与原子性

 

（4）  volatile不需要加锁，因此不会造成线程的阻塞，而且比synchronized更轻量级，而synchronized可能导致线程的阻塞

 

（5）  volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

 

 

### 5.死锁

当一个线程等待由另一个线程持有的锁，而后者正在等待已被第一个线程持有的锁时，就会发生死锁。

 

#### 形成死锁条件：

（1）互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

（2）不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

（3）请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

（4）循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

### 并发编程之ThreadLocal

#### ThreadLocal简介

变量值的共享可以使用public static的形式，所有线程都使用同一个变量，如果想实现每一个线程都有自己的共享变量该如何实现呢？JDK中的ThreadLocal类正是为了解决这样的问题。

ThreadLocal类并不是用来解决多线程环境下的共享变量问题，而是用来提供线程内部的共享变量，在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。在线程中，可以通过get()/set()方法来访问变量。ThreadLocal实例通常来说都是private static类型的，它们希望将状态与线程进行关联。这种变量在线程的生命周期内起作用，可以减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。

![image-20201112173744375](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20201112173746.png)





#### ThreadLocal源码解析

ThreadLocal常用方法介绍

![image-20201112173818161](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20201112173820.png)

get()方法：获取与当前线程关联的ThreadLocal值。

set(T value)方法：设置与当前线程关联的ThreadLocal值。

initialValue()方法：设置与当前线程关联的ThreadLocal初始值。

 

当调用get()方法的时候，若是与当前线程关联的ThreadLocal值已经被设置过，则不会调用initialValue()方法；否则，会调用initialValue()方法来进行初始值的设置。通常initialValue()方法只会被调用一次，除非调用了remove()方法之后又调用get()方法，此时，与当前线程关联的ThreadLocal值处于没有设置过的状态（其状态体现在源码中，就是线程的ThreadLocalMap对象是否为null），initialValue()方法仍会被调用。

initialValue()方法是protected类型的，很显然是建议在子类重载该函数的，所以通常该方法都会以匿名内部类的形式被重载，以指定初始值，

 

#### 实现原理

ThreadLocal最简单的实现方式就是ThreadLocal类内部有一个线程安全的Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。

**get()****方法的源码：**

![image-20201112173842038](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20201112173843.png)

get()方法主要做了以下事情：

1、调用Thread.currentThread()获取当前线程对象t；

2、根据当前线程对象，调用getMap(Thread)获取线程对应的ThreadLocalMap对象

3、如果获取的map不为空，则在map中以ThreadLocal的引用作为key来在map中获取对应的value e，否则转到步骤5；

4、若e不为null，则返回e中存储的value值，否则转到步骤5；

5、调用setInitialValue()方法，对线程的ThreadLocalMap对象进行初始化操作，ThreadLocalMap对象的key为ThreadLocal对象，value为initialValue()方法的返回值。

 

**总结**：可以看到，ThreadLocal的实现离不开ThreadLocalMap类，ThreadLocalMap类是ThreadLocal的静态内部类。每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。

 

**这样的设计主要有以下几点优势：**

这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能；当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。

### 线程池

使用new Thread实例实现多线程，有很多弊端。比如：

1. 线程生命周期开销非常大，创建线程都会需要时间延迟处理的请求，需要虚拟机和操作系统提供一些辅助操作。

2. 资源消耗，活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程将会闲置。大量空闲的线程会占用许多内存，给GC带来压力，而且大量线程在竞争CPU资源时会产生其他的性能开销。

3. 稳定性线程的数量是受到一定限制，随着不断增加可以提高系统的吞吐率（指令条数/执行时间），但如果超出预期的范围再创建更多线程只会降低程序的执行效率甚至导致系统崩溃。

所以在线程频繁创建的情况就有了线程池，它类似于工作队列相当于一组管理线程工作的资源池，获取任务并执行任务，然后返回线程池等待下一个任务，线程池启动初期线程不会启动，有任务提交(调用execute或submit) 才会启动，直到到达最大数量就不再创建而是进入阻塞队列，优点通过重用现有的线程而不是创建新线程，可以处理多个请求时分摊在创建线程和销毁过程中产生的巨大开销，另外当请求到达时，工作线程通常已经存在，因此不会由于创建线程而延迟任务的执行，从而提高了性能。

线程池的四种方式：

1. FixedThreadPool的用法 采用基于链表的阻塞队列 创建一个定长线程池，每当提交一个任务时就创建一个线程，直到线程池的最大数量，这时线程池的规模将不再变化 private static final ExecutorService bachTaskPool= Executors.newFixedThreadPool(2); //使用了阻塞队列，超过池子容量的线程会在队列中等待。
2.  CachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活收回空闲线程，若无可回收，则新建线程。private static final ExecutorService bachTaskPool=Executors.newCachedThreadPool(); //源码使用的是同步队列。
3.  SingleThreadPool 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。类似于单线程执行的效果一样。 private static final ExecutorService bachTaskPool=Executors.newSingleThreadExecutor();//源码采用的阻塞队列模式。
4. ScheduledThreadPool 创建一个定长线程池(会指定容量初始化大小)，支持定时及周期性任务执行。可以实现一次性的执行延迟任务，也可以实现周期性的执行任务。 private static final ScheduledExecutorService bachTaskPool = Executors.newScheduledThreadPool(2);//任务调度功能 源码使用的是延迟队列。



## 自定义注解

### 注解说明[#](https://www.cnblogs.com/jajian/p/9695055.html#注解说明)

Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。
Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。

### 内置注解[#](https://www.cnblogs.com/jajian/p/9695055.html#内置注解)

Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。
1、作用在代码的注解是

- `@Override` - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。
- `@Deprecated` - 标记过时方法。如果使用该方法，会报编译警告。
- `@SuppressWarnings` - 指示编译器去忽略注解中声明的警告。

2、作用在其他注解的注解(或者说**元注解**)是:

- `@Retention` - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
- `@Documented` - 标记这些注解是否包含在用户文档中。
- `@Target` - 标记这个注解应该是哪种 Java 成员。
- `@Inherited` - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

3、从 Java 7 开始，额外添加了 3 个注解:

- `@SafeVarargs` - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
- `@FunctionalInterface` - Java 8 开始支持，标识一个匿名函数或函数式接口。
- `@Repeatable` - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。

### 元注解[#](https://www.cnblogs.com/jajian/p/9695055.html#元注解)

1. **@Retention**

`@Retention` annotation指定标记注释的存储方式：

- RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。
- RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。
- RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。

2. **@Documented**

`@Documented` 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。

3. **@Target**

`@Target` 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值

- ElementType.TYPE 可以应用于类的任何元素。
- ElementType.FIELD 可以应用于字段或属性。
- ElementType.METHOD 可以应用于方法级注释。
- ElementType.PARAMETER 可以应用于方法的参数。
- ElementType.CONSTRUCTOR 可以应用于构造函数。
- ElementType.LOCAL_VARIABLE 可以应用于局部变量。
- ElementType.ANNOTATION_TYPE 可以应用于注释类型。
- ElementType.PACKAGE 可以应用于包声明。
- ElementType.TYPE_PARAMETER
- ElementType.TYPE_USE

4. **@Inherited**

`@Inherited` 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。

5. **@Repeatable**

Repeatable Java SE 8中引入的，`@Repeatable`注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。

### 自定义注解[#](https://www.cnblogs.com/jajian/p/9695055.html#自定义注解)

Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface SPI {
    /**
     * default extension name
     */
    String value() default "";
}
```









































####

 

 

 

 