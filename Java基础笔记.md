# Java基础笔记

<center>-------------------------接触新项目或者新功能之前需要注意以下几点----------------------</center>

<center>1. 弄懂项目中的专业名词或者技术中出现的技术点，必须知道概念。</center>

<center>2. 使用Xmind将相关专业名词和技术点记下来，同时，将系统的功能列出来</center>				

## 1.继承

### 什么是继承？

多个类存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。

注释：多个类称为子类，一个类称为父类、超类和基类。

 

### 继承语法

```
class 子类名 extends 父类名{

  ……

}
```

###  继承的特点

1. Java只支持单继承，不支持多继承（一个类只能有一个父类，不可能有多个父类）

2. Java支持多层继承（继承体系），即继承有传递性，子类还可以有子类                              

3. 一切类的祖先——java.lang.Object，所有类都直接或者间接地继承了java.lang.Object，Object类提供了以下方法

    ![image-20200704172619431](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184314.png)

4. 子类继承是继承父类的所有东西，除了构造函数

5. 方法重写(覆盖)。子类方法不能缩小父类方法的访问权限，如果没写访问权限（public, private等），则为默认修饰符没有public大

### 继承条件下类的访问权限

子类自动拥有父类申明的public和protected的成员，这是继承特性的体现之一。

private：属性和方法能被子类继承，无法被子类直接使用；<span style="color: red">但是将private属性包装到public方法中</span>，则能被子类使用

public：可以被子类直接使用

protected：同一包中的子类可以使用，另一包中的子类也可以使用

default：如果不知名任何权限，则默认同一包中的类可以访问

 ![image-20200704172629445](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184516.png)

访问权限：public>protected> default>private

注释：private方法只可以在类的内部使用，在类外根本访问不到，而final方法可以在类外访问，但是不可以重写该方法

 

### **java****对象初始化顺序**

1. 父类静态代码块，父类静态成员变量（同级，按代码顺序执行）

2. 子类静态代码块，子类静态成员变量（同级，按代码顺序执行）

3. 父类普通代码块，父类普通成员变量（同级，按代码顺序执行）

4. 父类构造方法

5. 子类普通代码块，子类普通成员变量（同级，按代码顺序执行）

6. 子类构造方法




### 不允许继承的类

```
final class 类名{

 }
```

1.  以final声明的方法不允许覆盖

2.  以final声明的变量不允许更改

3.  利用final可以设计出一种特殊的“只读”的“不可变类”


 用处：可以方便和安全地用于多线程环境中；

   访问它们可以不用加锁，因为能提供较高的性能；

 

### this和super

#### this：当前对象的引用

\1. 本类在非静态方法中使用非静态变量和非静态方法，可以使用【this.变量名】和【this.方法名(参数列表)】的方式调用，实际情况是，this关键字通常被省略

\2. 在上面的情况下，包含一个特殊情况，假如方法中定义了一个与类成员变量同名的局部变量，这时在方法内部调用类的成员变量就必须使用this关键字来引用

\3. 由this函数指向的构造函数默认有super()方法

 

#### super：父类对象的引用

\1. 子类重写父类方法之后，再次调用父类的该方法，必须使用【super.方法名(参数列表)】调用

\2. 子类的构造方法中默认调用了父类的无参构造方法，也可显示声明其他的构造方法，声明必须使用【super(列表参数)】

\3. 在构造方法中，super与this关键字不能同时出现，且位于构造方法首行

\4. 静态方法中不能使用super

## 2.抽象和接口

### 抽象

在Java继承中，抽象类和普通继承关系中的父类作用基本相同，但是却在一般父类的基础上添加了一些限制：

\1. 抽象类不能被实例化，即不能被new对象，其子类只有实现了抽象类中的抽象方法子类才能被实例化；如果抽象类中没有抽象方法，则子类可以直接实例化

\2. 抽象类除了包含一般方法，变量，常量，同时自身还包含抽象方法

\3. 抽象类的子类必须实现抽象类中的所有抽象方法，除非它自己也声明为抽象类，但是这样做，子类则不能被实例化

\4. 如果一个类中有抽象方法，则这个类必定是抽象类

\5. 抽象方法和抽象类看上去是多余的，当然实际运用中，抽象类能实现的，我们可以使用一般的继承和接口实现，当然，存在即是有道理的，如果熟练运用的话，可以写更少的代码实现相同的功能

\6. 抽象方法不可以有函数体（含有大括号的叫函数体）

\7. 抽象类可以有构造方法

 

 

 

抽象类举例：

 ![image-20200704172642349](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184431.png)

 ![image-20200704172647074](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184438.png)

 

### 接口

从本质上来说，接口是一种特殊的抽象类：

\1. 接口由常量和抽象方法组成，接口中的方法可以省略abstract书写

\2. public abstract书写（默认方法）, 默认修饰变量属性用：public static final

\3. 接口中可以定义default方法，如default void d()；

\4. 接口不能被实例化

\5. 接口可以继承多个接口

\6. 定义default方法时，可以有函数体，函数体内可以有变量。

 

接口举例：

 ![image-20200704172718439](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184455.png)           

 ![image-20200704172708751](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184500.png)

 

 

 

### 抽象类和接口比较

相同点：

都不能直接实例化，即不能直接new对象，通过多态性，可由其子类实例化

不同点：

\1. 抽象类包含一般方法，变量，常量，抽象方法；而接口只能包含常量和抽象方法

\2. 抽象类可以有构造方法，而接口不能有构造方法

\3. 一个类可以实现多个接口，但只能继承一个抽象类

\4. 继承抽象类时会引发单继承所带来的局限性，而通过实现接口的方式能够解决单继承带来的局限性

\5. 接口里不能定义静态方法，抽象类可以

\6. 接口所有方法全是抽象方法只能用public abstract修饰 （默认public abstract修饰 ），属性默认public static final修饰。抽象类除了包含抽象方法外与普通类无区别。

\7. 一个类同时要实现接口和继承类，顺序为先继承再实现

 

 

 

## 3.Static关键字

### Static简述：

我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。此时就是 static 大显身手的时候了！！

 

### Static变量

特性：

\1. 自从static变量被定义起，就会一直在类中存在，如果该变量在使用过程中，值被修改，再次调用该变量时，使用的是被改变后的值，这种情况直到类被卸载（结束）为止。

\2. static修饰的变量未赋初始值，如果是int类型，则初始值为0，如果是String类型，则初始值为空

 

\3. 可以通过类名直接访问静态变量，非静态变量不能直接通过类名访问

 

\4. Static不能修饰局部变量

 

\5. 如果没有定义static的方法和变量或者常量，就不会出现线程安全问题。

 ![image-20200704172741460](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184526.png)

 ![image-20200704172744926](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184534.png)

 

Static定义代码块：

 ![image-20200704172749866](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184538.png)

 

### Static方法

特性：

**1.**  **静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。**

\2.  **如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量**。

 

**3.**  **在普通成员方法中，则可以直接访问同类的非静态变量和静态变量.**

**4.**  **静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。**

 ![image-20200704172756215](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184602.png)

\5.  可以通过类名直接访问静态方法，非静态方法不能直接通过类名访问

\6.  定义顺序static final int

 ![image-20200704172801942](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184614.png)

### static包静态导入

 

如第一行，当引用Math包的时候，如果在引用的时候加static，调用Math中的静态变量和静态方法的时候，就可以直接写变量名或者方法名，而不用这样写：

 ![image-20200704172809372](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184620.png)

 

 

 

## 5. final关键字

### final

1.final修饰的类不能被继承，即不能有子类，final不能修饰抽象类。

2.final修饰的成员变量不能再被改变，即final修饰的是常量。

3.final修饰的方法不能被重写，但是可以被重载

4.final修饰的方法参数不允许在方法体内重新赋值

5.final不能修饰接口

 ![image-20200704172817137](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184625.png)

 ![image-20200704172819634](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184654.png)

 

### finalize方法

一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！

## 5.内部类

在Java中，可以将一个类定义在另一个类里面或者方法里面，这样的类称为内部类。

内部类一般来说包括四种：成员内部类，局部内部类，匿名内部类和静态内部类。

### 成员内部类

成员内部类是最普通的内部类，它的定义位于另一个类内部

 ![image-20200704172826252](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184702.png)

\1. 这样看起来，Draw像是Circle类的一个成员，Circle称为外部类，内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和static成员）。

\2. 当成员内部类拥有和外部类同名的成员变量或者方法时，就会发生隐藏现象，默认情况下是访问的是成员内部的成员，若要访问外部类的同名成员，则形式为----------------------外部类.this.成员变量、外部类.this.成员方法。

\3. 如果外部类要访问内部类的成员，必须先创建内部类的实例化。

 

### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问权限仅限于方法内部或者该作用域内。

 ![image-20200704172831383](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184707.png)

注意：局部内部类就像方法内的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

 

### 匿名内部类

匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。

特性：

\1. 匿名内部类只能继承或者实现一个类或者接口

\2. 匿名内部类只能用默认的构造方法不能自己添加(匿名内部类根本就没有类名!!!)

\3. 匿名内部类就是在创造的时候直接继承某个类，或者实现某个接口

 

 

例子1：

 ![image-20200704172838218](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184715.png)

例子2：

 ![image-20200704172842089](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184719.png)

例子2虽然能达到同样的效果，但是冗长又难以维护，所以一般使用第一种方法

 

匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

 

### 静态内部类（静态嵌套类）

注：静态内部类说法不严谨，正确应该说成静态嵌套类

静态内部类（又名嵌套类）也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。

 ![image-20200704172851453](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184725.png)

 

### 为什么在Java中需要内部类？

1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，

2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。

3.方便编写事件驱动程序

4.方便编写线程代码

 

## 7.  Java集合框架

概述：

\1. List , Set, Map都是接口，前两个继承至collection接口，Map为独立接口

\2. Set下有HashSet，LinkedHashSet，TreeSet

\3. List下有ArrayList，Vector，LinkedList

\4. Map下有Hashtable，LinkedHashMap，HashMap，TreeMap

\5. collection接口下还有个Queue接口，有PriorityQueue、LinkedList

 ![image-20200704172902893](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184732.png)

 ![image-20200704172910595](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184737.png)

 

Map   Properties      安全

​    ConcurrentHashMap 安全（采用Segment 的结构保证线程安全）

### Collection：

实现或者继承了collection接口的有List、Set、queue

 

1、Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式

 

2、Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

 

异同：Collections 是一个包装类，Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许，一些 collection 是有序的，而另一些则是无序的。

 

### List接口：

— List 有序,可重复

 

 

l Vector

优点: 底层数据结构是数组，查询快，增删慢。

缺点: 线程安全，效率低

 

 

l 可变数组ArrayList

ArrayList底层使用数组作为实现结构，但是元素个数不受限制，是大小可变的数组在内存中分配连续的空间。

 

优点: 底层数据结构是数组，查询快，增删慢。

缺点: 线程不安全，效率高

 

 

注：ArrayList集合中的元素是有序的

泛型<E>：可以保证接口中的操作内容更加安全，不这样做就很难避免存储类型杂乱

 

l 链接表LinkedList

LinkedList底层采用链式存储结构，插入、删除元素是不会引起大量元素的移动，效率高。

它专门提供了对尾部和头部添加和删除的删除方法，而且效率很高

 

优点: 底层数据结构是链表，查询慢，增删快。

缺点: 线程不安全，效率高

 

 

### Set接口：

—Set 无序,唯一

 

HashSet

底层数据结构是哈希表。(无序,唯一)

#### hashCode()和equals()

如何来保证元素唯一性?

1.依赖两个方法：hashCode()和equals()

1）hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

2）hashCode() 在散列表中才有用，在其它情况下没用。

3）“没有覆盖equals()方法”的情况：调用的Object.java的equals()方法，即调用的 (p1==p2)，判断两个对象地址是否相等，比较“p1和p2是否是同一个对象”。

4）“覆盖equals()方法”的情况：判断两个对象是否相等。

5）String类满足拥有相同字符的字符串产生同样的哈希码，即只要满足equals相等，hashCode就相等。

 

 

LinkedHashSet

底层数据结构是链表和哈希表。(FIFO插入有序,唯一)

1.由链表保证元素有序

2.由哈希表保证元素唯一

 

TreeSet

底层数据结构是红黑树。(唯一，有序)

\1. 如何保证元素排序的呢?

自然排序

比较器排序

2.如何保证元素唯一性的呢?

根据比较的返回值是否是0来决定

 

 

Set接口特点：

 \* （1）无序的，即放进去的顺序和出来的顺序不同

 \* （2）不可重复，注重独一无二的性质

 \* （3）HashSet继承自AbstractSet

 \* Set接口有两个重要的实现类：HashSet和TreeSet

 

l HashSet

引用相等性：引用堆上同一对象的两个引用是相等的。

对象相等性：堆上的两个不同对象在意义上是相同的。

引用相等性被HashSet认为是重复元素，但是对于对象相等性，HashSet并不认为是重复的。

 

l TreeSet

TreeSet存储自定义类型的对象

 

### Iterator迭代器：

（1）使用iterator()要求容器返回一个Iterator。

（2）注意：iterator()方法是java.lang.Iterable接口,被Collection继承。

（3）使用next()方法获得序列中的下一个元素 

（4）使用hasNext()检查序列中是否还有元素

（5）使用remove()方法将迭代器新返回的元素删除

（6）Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，

 *它可以从两个方向遍历List，也可以从List中插入和删除元素。

 

 

### Map接口：

Map接口有三个比较重要的实现类，分别是HashMap、TreeMap、Properties和HashTable。

 

\1. TreeMap是有序的，HashMap和HashTable是无序的。

\2. Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。

\3. 这就意味着:Hashtable是线程安全的，HashMap不是线程安全的。

\4. HashMap效率较高，Hashtable效率较低。

\5. 如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。

\6. Hashtable不允许null值，HashMap允许null值（key和value都允许）

\7. 父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap

 

 

 

 

 

（1）键（Key）不允许重复。 

（2）一个键（Key）只能映射到一个值（Value）。

（3）Map接口本身有3个常用子类：HashMap，HashTable，TreeMap，但是HashTable已经标为过时。

 

l HashMap

 ![image-20200704172933723](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185427.png)

（1）   集合中的元素不会按次序排列

（2）   HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。

（3）   HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。

（4）   HashMap实现不同步，线程不安全。 HashTable线程安全

（5）   HashMap中的key-value都是存储在Entry中的。

（6）   HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性

（7）   解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的

**HashMap****常用方法：**

 *void clear()-------------------------------------清除所有映射单元

 *Set<K> keySet()----------------------------------返回所有key的集合

 *Collection<V> values()---------------------------返回所有值得集合

 *Set<Map.Entry<K, V>> entrySet()------------------返回键值对的集合

 *V get(Object key)--------------------------------根据键取得值

 *V put(K key, V value)----------------------------存值

 *V remove(Object key)-----------------------------删除指定键所对应的值

 *void putAll(Map<? extends K, ? extends V>m)------集合复制

 *boolean containsKey(Object key)------------------判断是否包含某个键

 *boolean containsValue(Object value)--------------判断是否包含某个值

 

l TreeMap

（1）TreeMap底层采用红黑树结构，而HashMap使用哈希表结构

（2）TreeMap中的元素按Key自动排序，而HashMap是无序的

（3）TreeMap常用方法：

 *void clear()-------------------------------------清除所有映射单元

 *Set<K> keySet()----------------------------------返回所有key的集合

 *Collection<V> values()---------------------------返回所有值得集合

 *Set<Map.Entry<K, V>> entrySet()------------------返回键值对的集合

 *V get(Object key)--------------------------------根据键取得值

 *V put(K key, V value)----------------------------存值

 *V remove(Object key)-----------------------------删除指定键所对应的值

 *void putAll(Map<? extends K, ? extends V>m)------集合复制

 *boolean containsKey(Object key)------------------判断是否包含某个键

 *boolean containsValue(Object value)--------------判断是否包含某个值

 

 

### 队列queue：

**概述：**

\1. 队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

\2. LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。

 

**两个基本用法:**

\1. 在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞

 ![image-20200704172953601](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185422.png)

\2. 在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。

 

 

**基本操作：**

add     增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常

remove    移除并返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常

element   返回队列头部的元素   如果队列为空，则抛出一个NoSuchElementException异常

offer      添加一个元素并返回true   如果队列已满，则返回false

poll      移除并返问队列头部的元素  如果队列为空，则返回null

peek     返回队列头部的元素     如果队列为空，则返回null

put     添加一个元素        如果队列满，则阻塞

take      移除并返回队列头部的元素  如果队列为空，则阻塞

 

 

### Java常用的数据结构

数组、栈 、队列、链表、树、堆 、图、散列表（哈希表）。

1：数组是计算机编程语言上，对于“Array”的中文称呼，是用于储存多个相同类型数据的集合。

 

2：栈是限定仅在表尾进行插入和删除操作的线性表，栈者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。

 

3：一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

4：链表，一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

5：哈希表，是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

 

 

 

 

## 8.  JVM虚拟机

l Java 虚拟机：Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。

l JVM实现了Java语言最重要的特征：即平台无关性。

l 原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证，同时也是 Java 程序的安全检验引擎（还进行安全检查）。

l JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area。类加载器（classloader）把硬盘上的class 文件加载到JVM中的运行时数据区域（runtime data area）, 但是它不负责这个类文件能否执行，而这个是执行引擎（execution engine）负责

 

### classloader

l 作用：装载.class文件

l classloader 有两种装载class的方式 （时机）：

隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM

显式：通过class.forname()动态加载

**双亲委派模型**

1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。

2.当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.

\3. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。

 ![image-20200704173009110](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185417.png)

 

 

 

 

 

 

 

 

 

### Jvm内存区

JVM内存区：程序计数器、虚拟机栈、本地方法栈、堆、方法

区（包括常量池）。

 

1.程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。

 

2.Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。

 

3.本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。

 

4.Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。

 

5.方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。

 

6.运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。

 ![image-20200704173020175](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185412.png)

 

 

**JVM****中**

堆区：只存放类对象，线程共享，以及存放用new产生的数据；

方法区：又叫静态存储区，存放class文件和静态数据，线程共享;

栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;

全局区：全局变量，以及static变量

 

**进程的区**

一条进程的栈区、堆区、数据区和代码区在内存中的映射 
   1>栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。 
   2>堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你能够 free和delete它们。 
   3>数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。 

 

## 9.  重写，覆盖，重载

### 构造方法

1. 在同一个类中，如果一个方法要调用构造方法，这个构造方法应该被定义成private权限的方法，同时不能被子类继承。

2. 构造方法不能被对象调用，只会创建对象，使用new关键字




### 重写（覆盖）

**定义**：一般是用于子类在继承父类时，重写（重新实现）父类中的方法

**规则**：方法重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。

1、重写方法的参数列表必须完全与被重写的方法的相同

2、子类中方法的访问修饰符必须 >= 父类中对应方法的访问修饰符（public>protected>default>private）。

3、重写的方法的返回值必须和被重写的方法的返回一致；

4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；

5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。

6、静态方法不能被重写为非静态的方法（会编译出错）。

7、构造函数不能被继承，构造方法只能被显式或隐式的调用。

### 重载

**定义**：在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。

**规则**：

1、在使用重载时只能通过相同的方法名、不同的参数形式实现。可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）；

  2、不能通过访问权限、返回类型、抛出的异常进行重载；

  3、方法的异常类型和数目不会对重载造成影响；

 

## 9.&、|、^、~、>>、>>>

l &和|属于位运算符 不管前面的条件是否正确，后面都执行

l ＆ 如果相对应位都是1，则结果为1，否则为0

l | 如果相对应位都是0，则结果为0，否则为1

l ^是异或运算符两个操作数的位中，相同则结果为0，不同则结果为1。

l ~是位运算符，意义是 按位非（NOT）

按位非也叫做补，一元运算符NOT“~”是对其运算数的每一位取反。

仅用于整数值

反转位，即0位变为1位，1变成0

在所有情况下〜x等于（-x）- 1

l <<表示左移移，不分正负数，低位补0；　

例子：正数：r = 20 << 2

　　   20的二进制补码：0001 0100

　　   向左移动两位后：0101 0000

　　   结果：r = 80

负数：r = -20 << 2

　　   -20 的二进制原码 ：1001 0100

　　   -20 的二进制反码 ：1110 1011

　　   -20 的二进制补码 ：1110 1100

　　   左移两位后的补码：1011 0000

　　　　　　　　反码：1010 1111

　　　　　　　　原码：1101 0000 

　　　　　　　　结果：r = -80

l >>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；

例子：正数：r = 20 >> 2

　    20的二进制补码：0001 0100

　　   向右移动两位后：0000 0101

　　　　　　　结果：r = 5

负数：r = -20 >> 2

　　   -20 的二进制原码 ：1001 0100

　　   -20 的二进制反码 ：1110 1011

　　   -20 的二进制补码 ：1110 1100 

　　   右移两位后的补码：1111 1011 

　　　　　　　　反码：1111 1010

　　　　　　　　原码：1000 0101

　　　　　　　　结果：r = -5

l >>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0

 

例子：正数：　r = 20 >>> 2

　　　   结果与 r = 20 >> 2 相同；

负数：　r = -20 >>> 2

　　  -20:源码：10000000 00000000 00000000 00010100

　　　　反码：11111111 11111111  11111111  11101011

　　　　补码：11111111 11111111  11111111  11101100

　　　　右移：00111111 11111111  11111111  11111011

　　　　结果：r = 1073741819

 

 

## 10. 数据类型分类

基本数据类型（或叫做原生类、内置类型）8种：

​       整数：byte，short，int，long（默认是int类型）

​       浮点类型： float，double（默认是double类型）

​       字符类型：char

​       布尔类型：boolean

引用数据类型5种：类 接口 数组 枚举 标注

（String属于引用数据类型，因为String是一个类）

注释：如果将基本数据类型定义的值传入方法中，只是将该值的地址传进去，当该方法返回该值时，原方法中该常量的值并没有改变，引用数据类型则恰恰相反，原方法中的常量的值会改变。

 ![image-20200704173037965](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185404.png)

### 各类型占用字节数：

 

|         | 默认值    | 存储需求（字节） | 取值范围     | 示例               |
| ------- | --------- | ---------------- | ------------ | ------------------ |
| byte    | 0         | 1                | -2^7—2^7-1   | byte b=10;         |
| char    | ‘ \u0000′ | 2                | 0—2^16-1     | char c=’c’ ;       |
| short   | 0         | 2                | -2^15—2^15-1 | short s=10;        |
| int     | 0         | 4                | -2^31—2^31-1 | int i=10;          |
| long    | 0         | 8                | -2^63—2^63-1 | long o=10L;        |
| float   | 0.0f      | 4                | -2^31—2^31-1 | float f=10.0F      |
| double  | 0.0d      | 8                | -2^63—2^63-1 | double d=10.0;     |
| boolean | false     | 1                | true\false   | boolean flag=true; |

 

### 引用数据类型和基本数据类型

引用数据类型是引用传递（call by reference）：引用传递不可以改变原变量的地址，但可以改变原变量的内容

 ![image-20200704173055770](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185400.png)

 

 

基本数据类型是值传递（call by value）：值传递不可以改变原变量的内容和地址

 ![image-20200704173101293](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185355.png)

 

 

### 引用类型

1、强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。

2、软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。

3、弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。

4、虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。

 

## 11.Applet的生命周期（需要学习）


 Applet 类中的四个方法给我们提供了一个框架，你可以在该框架上开发小程序：

 init: 该方法的目的是为你的 Applet 提供所需的任何初始化。在 Applet 标记内的 param 标签被处理后调用该方法。
 start: 浏览器调用 init 方法后，该方法被自动调用。每当用户从其他页面返回到包含 Applet 的页面时，则调用该方法。
 stop: 当用户从包含 Applet 的页面移除的时候，该方法自动被调用。因此，可以在相同的 Applet 中反复调用该方法。
 destroy: 此方法仅当浏览器正常关闭时调用。因为 Applet 只有在 HTML 网页上有效，所以你不应该在用户离开包含 Applet 的页面后遗漏任何资源。
 paint: 该方法在 start() 方法之后立即被调用，或者在 Applet 需要重绘在浏览器的时候调用。paint() 方法实际上继承于 java.awt。

 

## 12.节点流和处理流

按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。

节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.

处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。

### JAVA常用的节点流：

l 文 件 

FileInputStream，FileOutputStrean，FileReader FileWriter 文件进行处理的节点流。

l 字符串 

StringReader，StringWriter 对字符串进行处理的节点流。

l 数 组 

ByteArrayInputStream，ByteArrayOutputStream，CharArrayReader，CharArrayWriter，对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。

l 管道 

PipedInputStream，PipedOutputStream， PipedReaderPipedWriter，对管道进行处理的节点流。

### 常用处理流（关闭处理流使用关闭里面的节点流）

 

l 缓冲流

BufferedInputStrean，BufferedOutputStream，BufferedReader BufferedWriter ，增加缓冲功能，避免频繁读写硬盘。

l 转换流

InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。

l 数据流 

DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

### 流的关闭顺序

一般情况下是：先打开的后关闭，后打开的先关闭

另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b

可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。

 

 

 

## 13.异常exception

Java中的异常分为两大类：

\1. java异常类均继承于java.lang.Throwable。

\2. **checked exception**：指的是编译时异常，该类异常需要本函数必须处理的，用try和catch处理，或者用throws抛出异常，然后交给调用者去处理异常。

\3. **runtime exception**：指的是运行时异常，该类异常不必须本函数必须处理，当然也可以处理。

 ![image-20200704173115677](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185349.png)

 

 

## 14.正则表达式

参考文档：https://www.runoob.com/java/java-regular-expressions.html

 

### 包含的类：

Pattern 类：

pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

 

Matcher 类：

Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

 

PatternSyntaxException：

PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

 

### 正则表达式语法

 

## 15.运算优先级

 ![image-20200704173125307](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185346.png)

 

 

## 16.文件名后缀

.class 编译后的Java文件 
 .java是未编译的程序 
 .jsp是页面程序 
 .xml配置程序 
 .jar是.calss的集合

.exe为可执行文件

 

转化过程：java中源文件的后缀为.java，经过javac.exe编译后生成字节码文件，后缀为.class，再经过java.exe编译为可执行文件，后缀为.exe。

 

 

Java.exe是java虚拟机

javadoc.exe用来制作java文档

jdb.exe是java的调试器

javaprof.exe是剖析工具

 

 

 

## 17.ASCII码值

常见字符的ASCII码值如下：空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。

 

## 18.面向对象的六大基本原则和三大特性

### 封装

l 将对象的属性和实现细节隐藏起来，只提供公共的访问方式。

### 继承

l 继承是从已有的类派生出新的类，新的类能继承已有类的数据属性和行为，并扩展新的功能。

### 多态

l 允许不同类型的子对象对统一消息做出不同的响应。

 

### 单一职责原则（SRP）：

l 一个类应该仅有一个引起它变化的原因

### 开放封闭原则（OCP）： 

l 既开放又封闭，对扩展是开放的，对更改是封闭的！

l 扩展即扩展现行的模块，当我们软件的实际应用发生改变时，出现新的需求，就需要我们对模块进行扩展，使其能够满足新的需求！

l 更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件

### 里氏替换原则（LSP）： 

l 子类可以替换父类并且出现在父类能够出现的任何地方

l 这个原则也是在贯彻GOF倡导的面向接口编程！

l 在这个原则中父类应尽可能使用接口或者抽象类来实现！

### 依赖倒置原则（DIP）： 

传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！

所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！

 

### 接口隔离原则（ISP）：

l 使用多个专门的接口比使用单个接口要好的多！

 

## 19.处理字节流和字符流

字节流：

InputStream  

|-- FileInputStream (基本文件流）  

|-- BufferedInputStream  

|-- DataInputStream  

|-- ObjectInputStream

字符流

Reader

|-- InputStreamReader (byte->char 桥梁） 

|-- BufferedReader (常用） 

Writer

|-- OutputStreamWriter (char->byte 桥梁） 

|-- BufferedWriter 

|-- PrintWriter （常用）

 

 

## 20.String,StringBuffer与StringBuilder

**String** **字符串常量****
 \**StringBuffer\**** **字符串变量（线程安全）****
 \**StringBuilder\**** **字符串变量（非线程安全）**

 

String 类型和 StringBuffer 类型区别：主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。

StringBuffer 类则结果就不一样，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用

 

Java.lang.StringBuffer是线程安全的可变字符序列，一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。

 

java.lang.StringBuilder：一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

 

 

## 21.Java标识符命名规则

l 由26个英文字母大小写，数字：0-9 符号：_ $ 组成

l 标识符应以字母、_ 、$开头。

l 标识符不能是关键字。

l Java中严格区分大小写

 

## 22.Java单例模式

### 单例模式主要有3个特点：

1、单例类确保自己只有一个实例。

2、单例类必须自己创建自己的实例。

3、单例类必须为其他对象提供唯一的实例

### 单例模式的优点：

Java Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）

 

常见单例模式的实现方式：懒汉单例类和饿汉单例类

### 懒汉单例

定义：对于懒汉模式，我们可以这样理解：该单例类非常懒，只有在自身需要的时候才会行动，从来不知道及早做好准备。它在需要对象的时候，才判断是否已有对象，如果没有就立即创建一个对象，然后返回，如果已有对象就不再创建，立即返回。

注：懒汉模式只在外部对象第一次请求实例的时候才去创建。

 

 

 

代码示例：

public class Singleton2{

  private static Singleton2 a ;

  public static Singleton2 getSingleton2(){

​      if(a==null){

​        a = new Singleton2();

​      }

​      retrun a;

​    }

}

 

 

### 饿汉单例

定义：饿汉模式，该单例类非常饿，迫切需要吃东西，所以它在类加载的时候就立即创建对象

 

代码示例：

public class Singleton1{

  private static Singleton1 a = new Singleton1();

  public static Singleton1 getSingleton1(){

​      retrun a;

​    }

}

 

### 懒汉单例类和饿汉单例类的区别：

\1.  饿汉模式是线程安全的而懒汉模式存在安全问题,如需解决需添加双重检查锁机制

\2.  **懒汉模式**：它的特点是运行时获得对象的速度比较慢，但加载类的时候比较快。它在整个应用的生命周期只有一部分时间在占用资源。**饿汉模式**：它的特点是加载类的时候比较慢，但运行时获得对象的速度比较快。它从加载到应用结束会一直占用资源。

\3.  对重量级对象应用饿汉模式，类加载时速度慢，但运行时速度快；懒汉模式则与之相反，类加载时速度快，但运行时第一次获得对象的速度慢。

 

### 什么情况下使用单例模式：

\1. 控制资源的使用，通过线程同步来控制资源的并发访问；

\2. 控制实例产生的数量，达到节约资源的目的。

\3. 作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。

 

## 23.J2EE容器

WEB容器：给处于其中的应用程序组件（jsp，servlet）提供一个环境，使jsp，servlet直接与容器中的环境变量交互，不必关注其它系统问题。主要由WEB服务器来实现。 例如：tomcat,weblogic,websphere等。

 

EJB容器：Enterprise java bean容器。供给运行在其中的组件EJB各种管理功能,满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理,并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。

 

WEB容器更多的是跟基于HTTP的请求打交道。而EJB容器更多的和数据库、其它服务打交道。但他们都是把与外界的交互实现从而减轻应用程序的负担。例如SERVLET不用关心HTTP的细节，直接引用环境变量session,request,response就行、EJB不用关心数据库连接速度、各种事务控制，直接由容器来完成。

 

 

 

## 24. throw与throws

异常有两个过程，一个是抛出异常；一个是捕捉异常。

### 抛出异常

抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常

### 系统自动抛异常

当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。

 

### throw

throw是语句抛出一个异常。

语法：throw (异常对象);

   如： throw e;

 

一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常。

 

### throws

throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)

语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]{......}

   如：   public void function() throws Exception{......}

 

当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理。

 

### throw与throws的比较

1、throws出现在方法函数头；而throw出现在函数体。

 

2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。

 

3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

 

 

## 25.内联函数

1.内联函数就是指函数在被调用的地方直接展开，编译器在调用时不用像一般函数那样，参数压栈，返回时参数出栈以及资源释放等，这样提高了程序执行速度。

 

2.Java语言中有一个关键字final来指明那个函数是内联的，例：

 

public final void doSomething() {

 // to do something

}

\3. 内联不一定好，当被指定为内联的方法体很大时，展开的开销可能就已经超过了普通函数调用调用的时间，引入了内联反而降低了性能，因为在选择这个关键字应该慎重些，不过，在以后高版本的JVM中，在处理内联时做出了优化，它会根据方法的规模来确定是否展开调用。

## 26.java关键字

 ![image-20200704173150842](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185332.png)

 

## 27. Java中的序列化和反序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。

### 序列化作用

1.方便传输，速度快，还很安全，被调用方序列化，调用方反序列化即可拿到传输前最原始的java对象，常用于不同进程之间的对象传输

2.方便存储，不管是存储成文件还是数据库，都行，存储为文件，下回要用可以直接反序列拿到对象

### 如何使Java类可序列化？

 

通过实现java.io.Serializable接口，可以在Java类中启用可序列化。它是一个标记接口，意味着它不包含任何方法或字段，仅用于标识可序列化的语义。

 

### 如果我们试图序列化不可序列化的对象怎么办？

我们将得到一个 RuntimeException 异常：主线程中出现异常 java.io.NotSerializableException。

 

### Transient 关键字

transient修饰符仅适用于变量，不适用于方法和类。在序列化时，如果我们不想序列化特定变量以满足安全约束，那么我们应该将该变量声明为transient。执行序列化时，JVM会忽略transient变量的原始值并将默认值保存到文件中。因此，transient意味着不要序列化。

### 注意事项

\1. 为了不必要的报错麻烦： 序列化时最好是定义序列化版本id 即 public static final Long seriaVersionUID = 1L (默认) 或者 xxxxx L（自定义64位都行）。

\2. 因为反序列化会判断序列化中的id和类中的id是否一样，如果不定义虽然会自动生成，但如果后面改了东西列，所以还是自觉点定义一个id，省去好多麻烦。

\3. 同时记住静态变量不会被序列化的，它可不在堆内存中，序列化只会序列化堆内存。

 

## 28.int和Integer

①无论如何，Integer与new Integer不会相等。不会经历拆箱过程

 

②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false，java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数只会对-128到127之间的数进行缓存 

 

③两个都是new出来的,都为false 

 

④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比

 

 

## 29.IO流

### 1.字节流和字符流

字节流：可以处理所有类型的数据，如MP3，文字，视频等。在读取时，都到一个字节就返回一个字节。

在java中对应的类都以“Stream”结尾。

字符流：仅能处理文本数据，如TXT文本等。读到一个或者多个字节时，先查找制定的编码表，然后将查到的字符返回。

在java中对应的类都以“Writer”或“Reader”结尾。

### 2.字符字节与编码

字符：人们试用的记号；

举例：“1”,”“中”，“@”等；

字节：计算机中存储数据的单元，一个八位的二进制数，是一个很具体的储存空间；

举例：0x01，0x45.0xFA等（这里用16进制表示的）；

ANSI编码：系统预设的标准文字储存格式，不同国家和地区试用不同的标准；

Unicode：国际组织统一规定的UNICODE字符集，满足跨语言，跨平台进行文本转、处理的要求。

### 3.Buffer代表缓冲区的意思

带有缓冲的的字节输出流效率是非常高的，尤其是在进行大型文件的复制的时候，使用Buffer进行复制要快得多。

InputStreamReader：将字节流转换为字符流

 

## 30.同步与异步

**定义：**

l 同步:发送一个请求,等待返回,然后再发送下一个请求 

l 异步:发送一个请求,不等待返回,随时可以再发送下一个请求 

**概念：**

同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。

异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。

 

**区别：**

同步和异步最大的区别就在于。一个需要等待，一个不需要等待。

比如广播，就是一个异步例子。发起者不关心接收者的状态。不需要等待接收者的返回信息
 **举例：**

电话，就是一个同步例子。发起者需要等待接收者，接通电话后，通信才开始。需要等待接收者的返回信息

 

 

## 31.lambda表达式

### 表达式示例：

示例1：

 ![image-20200704173214107](D:%5CTypora%5CPicture%5Cimage-20200704173214107.png)

示例2：

 ![image-20200704173217667](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185326.png)

### lambda使用场景

\1. 实现延迟执行

延迟执行的大概原因：

1) 另一个单独的线程运行代码

2) 多次运行代码

3) 在算法的恰当时刻运行代码（例如，排序中的比较操作）

4) 当某些情况发生时运行代码（按钮被单击、数据到达等）

5) 只有在需要的时候运行代码

\2. 延迟执行的

 

 

### Lambda的作用域

Lambda表达式的方法体与嵌套代码块有着相同的作用域。因此，也适用同样的命名冲突和屏蔽规则。

 

 

 

 

 

 

 

 

 

## 32.方法引用和构造函数引用

### 方法引用

方法引用示例：

 ![image-20200704173228730](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185321.png)

操作符::将方法名称或类对象名称分隔开，三种书写方式：

\1. 类::实例方法

\2. 类::静态方法

\3. 对象::实例方法

 

 

### 构造函数引用

 

## 33.java日志logger 

### 日志记录器

定义：日志记录的载体。系统也有全局日志记录器，可以自己定义日志记录器。

创建示例：

 

 

### 日志级别

日志共分为7个级别：

 

默认情况下，前三个级别的日志会被记录下来。也可以设置不同的阀值，如：  ，FINE及以上级别的日志就会被记录下来。

 

## 34.泛型编程

泛型学习网址https://www.cnblogs.com/penghuwan/p/8420791.html

### 泛型的意义：

一般来说，你并不想要编写多个分别处理不同数据类型，但内在逻辑代码却完全一样的类。因为这些处理类可能除了数据类型变换了一下外，所有代码都完全一致。

### 泛型特性

\1. JavaSE7以后，在实例化一个泛型类对象时，构造函数中可以省略泛型类型

 ![image-20200704173243221](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185313.png)

\2. *T extends SuperClass* 与 *? extends SuperClass*的使用与区别

编译器可以通过泛型定义变量，但是不能通过通配符定义变量，

通配符需要调用泛型定义的方法进行变量定义：

 ![image-20200704173249835](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185308.png)

泛型（T）：

 ![image-20200704173254427](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185302.png)

通配符（?）:

 ![image-20200704173258498](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185255.png)

\3. 对于要求实现接口， 或者继承自某个父类， 统一使用extends关键字

\4. 问题

 ![image-20200704173304003](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185251.png)

 ![image-20200704173312018](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185244.png)

\5.  

### 泛型方法：

泛型变量T放在修饰符（这里是public static）的后面， 返回类型的前面

 ![image-20200704173317807](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704185241.png)

 

 

## 35.Java反射

反射链接：[反射学习网址](https://www.sczyh30.com/posts/Java/java-reflection-1/#一、回顾：什么是反射？) 

### 什么是反射

反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。

 

在java.lang.reflect包中有三个类：Field类、Method类和Constructor类分别描述了一个类的域、方法、构造函数。Field类有一个getType方法，该方法返回一个Class类型的对象，描述域的类型信息。

 ![image-20200704173323439](https://raw.githubusercontent.com/kender1314/NotePicture/master/20200704184824.png)

**反射主要提供的功能：**

-   在运行时判断任意一个对象所属的类；


- 在运行时构造任意一个类的对象；

- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；

- 在运行时调用任意一个对象的方法


重点：**是运行时而不是编译时**

### 反射主要用途

**反射最重要的用途就是开发各种通用框架。**很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。

 





## 36.Stream

 







## 设计模式

### 模式分类 

#### 根据目的来分

根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。

1. 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
2. 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
3. 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

####  根据作用范围来分

 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

 ![image-20200710173729835](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/image-20200710173729835.png)

###  GoF的23种设计模式的功能

 前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。

| 名称                                  | 功能                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| 单例（Singleton）模式                 | 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 |
| 原型（Prototype）模式                 | 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 |
| 工厂方法（Factory Method）模式        | 定义一个用于创建产品的接口，由子类决定生产什么产品。         |
| 抽象工厂（AbstractFactory）模式       | 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 |
| 建造者（Builder）模式                 | 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 |
| 代理（Proxy）模式                     | 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 |
| 适配器（Adapter）模式                 | 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 |
| 桥接（Bridge）模式                    | 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 |
| 装饰（Decorator）模式                 | 动态的给对象增加一些职责，即增加其额外的功能。               |
| 外观（Facade）模式                    | 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 |
| 享元（Flyweight）模式                 | 运用共享技术来有效地支持大量细粒度对象的复用。               |
| 组合（Composite）模式                 | 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 |
| 模板方法（TemplateMethod）模式        | 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 |
| 策略（Strategy）模式                  | 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 |
| 命令（Command）模式                   | 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 |
| 职责链（Chain of Responsibility）模式 | 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 |
| 状态（State）模式                     | 允许一个对象在其内部状态发生改变时改变其行为能力。           |
| 观察者（Observer）模式                | 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 |
| 中介者（Mediator）模式                | 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 |
| 迭代器（Iterator）模式                | 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 |
| 访问者（Visitor）模式                 | 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 |
| 备忘录（Memento）模式                 | 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 |
| 解释器（Interpreter）模式             | 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 |

### 面向对象设计七大原则

#### 开闭原则（Open Closed Principle，OCP）

##### 开闭原则定义

开闭原则：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

##### 开闭原则的作用

1. 降低了测试压力，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性，粒度越小，被复用的可能性就越大。
3. 软件的稳定性高和延续性强，从而易于扩展和维护。

##### 开闭原则的实现方法

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

#### 里氏替换原则（Liskov Substitution Principle，LSP）

##### 里氏替换原则定义

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

##### 里氏替换原则的作用

1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

##### 里氏替换原则的实现方法

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

#### 依赖倒置原则（Dependence Inversion Principle，DIP）

##### 依赖倒置原则的定义

传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！

DIP原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。

##### 依赖倒置原则的作用

1. 依赖倒置原则可以降低类间的耦合性。
2. 依赖倒置原则可以提高系统的稳定性。
3. 依赖倒置原则可以减少并行开发引起的风险。
4. 依赖倒置原则可以提高代码的可读性和可维护性。

##### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。































####

 

 

 

 