# Mysql数据库笔记

## 数据库系统

### 数据库定义

SQL：(Structured Query Language)结构化查询语言

数据库系统组成：数据库、数据库管理系统（DBMS）、应用系统和数据库管理员（DBA）

（18.3.10）

 

### 数据库系统的特点

1.数据结构化。

2.数据的共享性高，冗余度低，易扩充。

3.数据独立性高。

4.数据由DBMS统一管理和控制。

 

## 数据库管理系统

数据库管理系统提供相应的功能： 

1. 数据库恢复：在系统失效后的数据库恢复，配合定时备份数据库，使数据库不丢失数据。
2. 并发控制：保证多用户能共享数据库，并维护数据的一致性。 
3. 安全性保护：防止对数据库的非法使用，以避免数据的泄露、纂改或破坏。 
4. 完整性保护：保证数据的正确性和一致性。

 

### MySQL

注：

1. MySQL是关系型数据库：表与表之间存在关系

2. 在mysql的控制命令中，所有SQL语句必须加分号（MySQL语句有些可以不加）

#### MySQL实现了四种通信协议

1. TCP/IP协议，通常我们通过来连接MySQL，各种主要编程语言都是根据这个协议实现了连接模块

2. Unix Socket协议，这个通常我们登入MySQL服务器中使用这个协议，因为要使用这个协议连接MySQL需要一个物理文件，文件的存放位置在配置文件中有定义，值得一提的是，这是所有协议中最高效的一个。

3. Share Memory协议，这个协议一般人不知道，肯定也没用过，因为这个只有windows可以使用，使用这个协议需要在配置文件中在启动的时候使用–shared-memory参数，注意的是，使用此协议，一个host上只能有一个server，所以这个东西一般没啥用的，除非你怀疑其他协议不能正常工作，实际上微软的SQL Sever也支持这个协议

4. Named Pipes协议，这个协议也是只有windows才可以用，同shared memory一样，使用此协议，一个host上依然只能有一个server，即使是使用不同的端口也不行，Named Pipes 是为局域网而开发的协议。内存的一部分被某个进程用来向另一个进程传递信息，因此一个进程的输出就是另一个进程的输入。第二个进程可以是本地的（与第一个进程位于同一台计算机上），也可以是远程的（位于联网的计算机上）。正因为如此，假如你的环境中没有或者禁用TCP/IP环境，而且是windows服务器，那么好歹你的数据库还能工作。使用这个协议需要在启动的时候添加–enable-named-pipe选项

 

## 数据库的基本知识

### DDL

DDL(Data Definition Language)：数据定义语言DDL

数据定义语言DDL用来创建数据库中的各种对象-----表、视图、

索引、同义词、聚簇等如：

| CREATE | TABLE | VIEW | INDEX | SYN    | CLUSTER |
| ------ | ----- | ---- | ----- | ------ | ------- |
|        | 表    | 视图 | 索引  | 同义词 | 簇      |

DDL操作是隐性提交的！不能rollback



### DML

DML（data manipulation language）： 数据操纵语言

DML主要有三种形式：

1) 插入：INSERT

2) 更新：UPDATE

3) 删除：DELETE

 

### DQL

DQL（Data Query Language）：数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE。

子句组成的查询块：

SELECT <字段名表>

FROM <表或视图名>

WHERE <查询条件>

 

 

### DCL

DCL（Data Control Language）：数据控制语言DCL

数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制

数据库操纵事务发生的时间及效果，对数据库实行监视等。如：

1) GRANT：授权。

 

## 数据库（databases）基本操作指令

### 展示数据库（show）

show databases; ：在cmd中查询服务器有几个数据库

![image-20200911221740742](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911221742.png)

### 创建数据库（create）

create database 数据库名：创建数据库

![image-20200911221810890](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911221812.png)

### 删除数据库（drop）

drop database （table） 数据库名（表名）; ：删除数据库（表）

 ![image-20200911221822251](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911221825.png)

### 使用数据库（use）

use 数据库名;   ：使用数据库，显示如下结果

 ![image-20200911221837686](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911221839.png)

然后再使用  show tables;  ：显示数据库下有多少表

 ![image-20200911221844500](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911221845.png)

（18.3.11）

## varchar与char的区别

### 定长和变长

char 表示定长，长度固定，varchar表示变长，即长度可变。char如果插入的长度小于定义长度时，则用空格填充；varchar小于定义长度时，还是按实际长度存储，插入多长就存多长。

因为其长度固定，char的存取速度还是要比varchar要快得多，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar则刚好相反，以时间换空间。

### 存储的容量不同

对 char 来说，最多能存放的字符个数 255，和编码无关。

而 varchar 呢，最多能存放 65532 个字符。varchar的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节。



## 表结构基本操作指令

### 创建表（create）

1）通过新建查询建立表：

   ![image-20200911221933730](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222000.png)

  写法顺序

![image-20200911221957285](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222006.png)

  注：DEFAULT：设置默认值

   COMMENT：设置注释

   PRIMARY KEY：设置主键（主键的作用：表示数据的唯一性，便于搜索）

2）将已有的表2结构复制到表1

CREATE TABLE 表名1 like 表名2;  将已有的表2结构复制到表1

 ![image-20200911222014000](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222021.png)

复制一个表，包括表结构以及表数据（可以设置复制部分数据，如下图第二种方法）

 ![image-20200911222031175](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222032.png)

（18.3.12）

### 替换表名（alter）

 ALTER TABLE 原表名  RENAME TO 新表名;  ：更换表名

### 删除表（delete）

  DROP TABLE 表名;     ：删除表

  TRUNCATE 表名;       ：清空列表数据

 ![image-20200911222042956](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222046.png)

 

### 添加删除字段

下图是表中字段的添加方法

 ![image-20200911222059057](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222229.png)

字段的删除方法：ALTER TABLE 表名 DROP 所删除字段名;

 ![image-20200911222113704](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222225.png)

修改列定义

 ![image-20200911222118776](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222220.png)

## 数据库三大范式

1. 第一范式（1NF）：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性
2. 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
3. 第三范式（3NF）：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；
4. 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖），消除了插入和删除异常

 ![image-20200911222212676](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222213.png)

## mysql中索引：

相当于快捷方式，重新开辟一个空间，存放索引，往空间中存放某些常用字段的索引，使搜索起来更为方便

1）查询索引：   SHOW INDEX FROM 表名;（默认查询表中主键）

 ![image-20200911222239075](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222240.png)

2）添加索引：   CREATE INDEX 索引名 ON 表名(字段名)

 ![image-20200911222248984](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222250.png)

3）删除索引：   DROP INDEX 索引名 ON 表名;

 ![image-20200911222255748](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222256.png)

## 数据操作基本指令

### 插入（insert）

  1）普通插入操作

 ![image-20200911222306070](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222307.png)

2）   将一个表中的数据插入到另一个表中

 ![image-20200911222313988](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222315.png)

 

### 更新（update）

表的更新 

 ![image-20200911222322178](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224125.png)

 

### 删除（delete）

表中数据的删除

 ![image-20200911222339531](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224131.png)

（18.3.13）

## 去除重复数据

SELECT DISTINCT 字段名 FROM 表名;   （distinct不显示重复的）

 ![image-20200911222348731](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222353.png)

## 列表排序 

ASC：表示升序，默认不写也是表示升序 。 

DESC：表示降序。

书写格式如下：

 ![image-20200911222422414](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224138.png)

## 分页查询（limit）

 LIMIT x,y ： x代表起始位置，y表示显示多少行，图中第三行表示先排序，再查询

 ![image-20200911222429640](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224144.png)

## WHERE的基本用法（相当于if的用法）

 ![image-20200911222438066](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224151.png)

## 模糊查询：

使用LIKE语句，%代表任意元素，无论个数多少‘_’也是代表任意元素，但是只能代表一位数。

 ![image-20200911222444983](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224202.png)

  如上图，第一行代表搜索名字开头为五的数据（该数据可能含有两个及两个以上的字），第二行代表搜索名字为五的数据，但是只能搜索数据为两个字的数据（一个下横杠代表一个字）

## 别名命名法

 ![image-20200911222502567](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224206.png)

作用：可以用于显示搜索字段，使阅读更为方便

 ![image-20200911222508778](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224215.png)

（18.3.14）

## 并列显示在一起 

 使用CONCAT(字段一,字段二……)

 ![image-20200911222514355](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224224.png)

 ![image-20200911222517967](../../../../Typora/Picture/image-20200911222517967.png)

## 求和，最大值，最小值，平均值

 ![image-20200911222522332](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224230.png)

## 计数函数

 ![image-20200911222530946](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224237.png)

当count后面是‘*’或者‘1’时，默认查询表中最长列

## 内容加密

MD5()实现加密，无法进行解密，目前测试无法对int数据进行加密（可能是方法不对）

 ![image-20200911222541793](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222542.png)

（18.3.15）

## 分组查询（查看数据出现的次数）

 ![image-20200911222547233](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224253.png)

![image-20200911222556753](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222558.png)

使用GROUP BY可以实现输出表中指定各个元素次数，该语句只能出现在WHERE语句之后，ORDER BY语句之前

HAVING语句与GROUP BY语句配套使用，目的是为了先过滤出有用的信息，然后再按要求进行分组

 ![image-20200911222604348](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224301.png)

 ![image-20200911222608430](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224310.png)

## WHERE

WHERE语句是行级过滤，会把不满足的剔除，剔除之后再分组

 与之对应的，HAVING语句是组级过滤，先分组，再过滤

## 交叉方式，内连接，外连接

### 交叉方式

  显式交叉方式：SELECT * FROM表1 S CROSS JOIN 表2 A WHERE S.STUDENT_CLASS = A.STUDENT_CLASS;

 ![image-20200911222613039](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224317.png)

  隐式交叉方式：SELECT * FROM 表1 S,表2 A WHERE S.STUDENT_CLASS = A.STUDENT_CLASS;

 ![image-20200911222618320](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224322.png)

两种交叉方式效果一样，都是组合两张表

### 内连接

  内连接：效果与交叉方式相同

 ![image-20200911222623679](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224329.png)

 

### 外连接

 外连接（与前两种连接的区别：前两种连接中，如果前表中有后表无法匹配的数值，前表中的数据则不会显示在结果中）

​    ![image-20200911222633533](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224343.png)

![image-20200911222640932](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222642.png)

———————————————————————————————————————

 ![image-20200911222649970](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222651.png)

以上为交叉式连接显示结果

 ![image-20200911222656811](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222658.png)

![image-20200911222816690](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224353.png)

以上为外连接结果

外连接包括左外连接（LEFT JOIN）和右外连接（RIGHT JOIN），表示结果以左面无NULL和右面无NULL

## 合并结果集

UNION：不显示重复数据

 ![image-20200911222721622](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222722.png)

![image-20200911222857526](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222858.png)



UNION ALL：可以显示重复数据

 ![image-20200911222911590](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222912.png)

 ![image-20200911222918534](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222919.png)

（18.3.16）

## 子查询

30中的交叉连接和内连接所出现的的结果集是一张虚拟表，不能当成一般的表使用，所以不能使用虚拟表进行相关查询，这时候就可以使用子查询进行相关查询

查询17级中的女生

 ![image-20200911222928133](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222929.png)

S.*,A.STUDENT_GRADE  

因为表一中STUDENT_CLASS与表二中STUDENT_CLASS发生冲突，所以定义的时候一定不能两个表同时出现相同的字段，查询比平均分高的同学

 ![image-20200911222942031](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222943.png)

这也是用的子查询，形式上有所不同而已

## 视图

### 定义

（以表举例）将虚拟的表另存储为一张新表，当再次使用子查询查询时，就不用每次再次构建虚拟表，直接使用新表进行查询，但是实质是每次使用的时候，软件都要帮我们自动查询，我们所看到的视图中的表，其实是不存在的

 ![image-20200911222953170](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911222954.png)

VIEW代表视图的意思

 

### 视图特性

1. 允许通过具有一些先决条件的数据库视图来更新基础表中的数据。

2. 当表的数据发生变化时，视图也反映了这些数据的变化。

 

### 视图特点

1. 数据库视图允许简化复杂查询：数据库视图由与许多基础表相关联的SQL语句定义。您可以使用数据库视图来隐藏最终用户和外部应用程序的基础表的复杂性。通过数据库视图，您只需使用简单的SQL语句，而不是使用具有多个连接的复杂的SQL语句。

2. 数据库视图有助于限制对特定用户的数据访问。您可能不希望所有用户都可以查询敏感数据的子集。可以使用数据库视图将非敏感数据仅显示给特定用户组。

3. 数据库视图提供额外的安全层。安全是任何关系数据库管理系统的重要组成部分。 数据库视图为数据库管理系统提供了额外的安全性。 数据库视图允许您创建只读视图，以将只读数据公开给特定用户。 用户只能以只读视图检索数据，但无法更新。

4. 数据库视图启用计算列。 数据库表不应该具有计算列，但数据库视图可以这样。 假设在orderDetails表中有quantityOrder(产品的数量)和priceEach(产品的价格)列。 但是，orderDetails表没有一个列用来存储订单的每个订单项的总销售额。如果有，数据库模式不是一个好的设计。 在这种情况下，您可以创建一个名为total的计算列，该列是quantityOrder和priceEach的乘积，以表示计算结果。当您从数据库视图中查询数据时，计算列的数据将随机计算产生。

5. 数据库视图实现向后兼容。 假设你有一个中央数据库，许多应用程序正在使用它。 有一天，您决定重新设计数据库以适应新的业务需求。删除一些表并创建新的表，并且不希望更改影响其他应用程序。在这种情况下，可以创建与将要删除的旧表相同的模式的数据库视图。

## 搜索引擎

MySQL用的是InnoDB储存引擎（在MySQL命令界面中show engines;查询）

### InnoDB

如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择

### MyISAM

如果数据表主要用来插入和查询记录，读操作明显多于写操作，存储量较大，则MyISAM引擎能提供较高的处理效率

### Memory

如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

### Archive

如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive

 

## 事务

有四个属性原子性、一致性、隔离性、持久性

事务主要用于某些过程，例如银行转账，或者某些数据的交接等等

 ![image-20200911223026699](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911223028.png)

事务：

   第一种方法，如果不关闭事务，继续修改年龄的值，也会受事务的影响

SET AUTOCOMMIT = FALSE;   事务的开启

COMMIT;          提交

SET AUTOCOMMIT = TRUE;  事务的关闭

第二种方法，每次事务只会作用一次，一次过后则自动关闭

START TRANSACTION;或BEGIN;

COMMIT;

同时也还有几种方法可以关闭

ROLLBACK回滚

异常结束

用户回话正常结束

## 事务隔离四个等级

### **Read uncommitted**（读未提交）

顾名思义，就是一个事务可以读取另一个未提交事务的数据。事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

### **Read committed**（读提交）

顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他买单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…

分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

 

### **Repeatable read**（重复读）

就是在开始读取数据（事务开启）时，不再允许修改操作

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他买单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

### **Serializable** **（序列化）**

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

38.悲观锁：就是比较悲观，认为别人访问数据都会修改数据，使用悲观锁就锁住了数据，不让别人看到，它是MySQL数据库的锁，它要与事务一起使用。 

![image-20200911223059270](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224435.png)

主要是控制mysql命令中的数据，如果点击commit，则不会出现下表

 ![image-20200911223224626](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224441.png)

（18.3.17）

## 数据库约束

1.—主键约束（Primay Key Coustraint） 唯一性，非空性

2.—唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个

3.—检查约束 (Check Counstraint) 对该列数据的范围、格式的限制（如：年龄、性别等）

4.—默认约束 (Default Counstraint) 该数据的默认值

5.—外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列

 

### 数据完整性约束

数据完整性约束指的是为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。

分为以下四类：

1) 实体完整性：规定表的每一行在表中是惟一的实体。

2) 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。

3) 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。

4) 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。

 

## 数据库事务并发带来的问题

数据库事务并发带来的问题有：更新丢失、脏读、不可重复读、幻象读。

 

假设张三办了一张招商银行卡，余额100元，分别说明上述情况。

### 更新丢失：

一个事务的更新覆盖了另一个事务的更新。事务A：向银行卡存钱100元。事务B：向银行卡存钱200元。A和B同时读到银行卡的余额，分别更新余额，后提交的事务B覆盖了事务A的更新。更新丢失本质上是写操作的冲突，解决办法是一个一个地写。

 

### 脏读：

一个事务读取了另一个事务未提交的数据。事务A：张三妻子给张三转账100元。事务B：张三查询余额。事务A转账后（还未提交），事务B查询多了100元。事务A由于某种问题，比如超时，进行回滚。事务B查询到的数据是假数据。脏读本质上是读写操作的冲突，解决办法是写完之后再读。

 

### 不可重复读：

一个事务两次读取同一个数据，两次读取的数据不一致。事务A：张三妻子给张三转账100元。事务B：张三两次查询余额。事务B第一次查询余额，事务A还没有转账，第二次查询余额，事务A已经转账了，导致一个事务中，两次读取同一个数据，读取的数据不一致。不可重复读本质上是读写操作的冲突，解决办法是读完再写。

 

### 幻读：

一个事务两次读取一个范围的记录，两次读取的记录数不一致。事务A：张三妻子两次查询张三有几张银行卡。事务B：张三新办一张银行卡。事务A第一次查询银行卡数的时候，张三还没有新办银行卡，第二次查询银行卡数的时候，张三已经新办了一张银行卡，导致两次读取的银行卡数不一样。幻象读本质上是读写操作的冲突，解决办法是读完再写。

 

### 幻读和不可重复读的区别

不可重复读的重点是修改：

同样的条件, 你读取过的数据, 再次读取出来发现值不一样了

幻读的重点在于新增或者删除：

同样的条件, 第1次和第2次读出来的记录数不一样

 

## JDBC

- 1.DriverManager：表示加载驱动

 ![image-20200911223245496](https://cdn.jsdelivr.net/gh/kender1314/NotePicture/20200911224511.png)

- JDBC的事务，connection支持提供事务的属性和方法，JDBC的连接在关闭的时候是写入数据库的，所以我们必须给出回滚。

（18.3.18）

 

## mysql日志

### 更新日志

以下操作会刷新日志文件，刷新日志文件时会关闭旧的日志文件并重新打开日志文件。对于有些日志类型，如二进制日志，刷新日志会滚动日志文件，而不仅仅是关闭并重新打开。

 mysql> FLUSH LOGS;

shell> mysqladmin flush-logs

shell> mysqladmin refresh

 

### 错误日志

错误日志是最重要的日志之一，它记录了MariaDB/MySQL服务启动和停止正确和错误的信息，还记录了mysqld实例运行过程中发生的错误事件信息。

 

### 查询日志

查询日志分为一般查询日志和慢查询日志，它们是通过查询是否超出变量 long_query_time 指定时间的值来判定的。在超时时间内完成的查询是一般查询，可以将其记录到一般查询日志中，但是建议关闭这种日志（默认是关闭的），超出时间的查询是慢查询，可以将其记录到慢查询日志中。

### 慢日志

查询超出变量 long_query_time 指定时间值的为慢查询。但是查询获取锁(包括锁等待)的时间不计入查询时间内。

### 二进制日志

二进制日志包含了引起或可能引起数据库改变(如delete语句但没有匹配行)的事件信息，但绝不会包括select和show这样的查询语句。语句以"事件"的形式保存，所以包含了时间、事件开始和结束位置等信息。

二进制日志是以事件形式记录的，不是事务日志(但可能是基于事务来记录二进制日志)，不代表它只记录innodb日志，myisam表也一样有二进制日志。

对于事务表的操作，二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入。对于非事务表的操作，每次执行完语句就直接写入。

 

## 数据库安全性控制的常用方法和技术

### (1)用户标识和鉴别：

该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才能提供系统的使用权

### (2)存取控制

通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未授权的人员无法存取数据

### (3)视图机制

为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。

### (4)审计

建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA（数据库管理员）可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人，时间和内容等。

### (5)数据加密

对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。

## 数据库三级模式

定义：人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括外模式、概念模式、内模式，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。用户级对应外模式，概念级对应概念模式，物理级对应内模式，使不同级别的用户对数据库形成不同的视图

### 外模式

外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。

### 概念模式

概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。

### 内模式

内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。

## 关系数据模型的三个组成部分

1.关系数据模型的数据结构

2.关系数据模型的操作集合

3.关系数据模型的完整性约束

















###